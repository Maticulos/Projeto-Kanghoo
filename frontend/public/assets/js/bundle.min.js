/* === app.js === */
document.addEventListener('DOMContentLoaded', function() {
    // Cache de elementos DOM
    const domCache = {
        smoothScrollLinks: document.querySelectorAll('a[href^="#"]'),
        scrollNav: document.querySelector('.scroll-nav'),
        animatedSections: document.querySelectorAll('.animated-section'),
        eventCards: document.querySelectorAll('.event-card'),
        mainEventImage: document.getElementById('event-main-image'),
        cadastroModal: document.getElementById('cadastroModal'),
        openModalBtn: document.getElementById('btn-cadastro-modal'),
        closeModalBtn: document.getElementById('close-modal'),
        progressBar: document.querySelector('.scroll-progress-bar')
    };

    // --- FUNÇÕES DE INICIALIZAÇÃO ---

    function init() {
        initSmoothScroll();
        initScrollNav();
        initScrollAnimations();
        initEventCards();
        initModals();
        initProgressBar();
        initBillingToggle();
        initImageErrorHandling();
        
    }

    /**
     * Adiciona o evento de scroll suave para links de âncora.
     * AGORA COM A CORREÇÃO PARA O BOTÃO DE SUBIR.
     */
    function initSmoothScroll() {
        domCache.smoothScrollLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');

                // Se o link for para o #header (botão de subir), rola para o topo da página
                if (targetId === '#header' || targetId === '#head') {
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                    return; // Interrompe a execução aqui
                }
                
                if (targetId === '#') return;

                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    }

    function initScrollNav() {
        if (!domCache.scrollNav) return;
        window.addEventListener('scroll', () => {
            domCache.scrollNav.classList.toggle('visible', window.scrollY > window.innerHeight / 2);
        });
    }

    function initScrollAnimations() {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                    observer.unobserve(entry.target);
                }
            });
        }, { threshold: 0.15 });
        domCache.animatedSections.forEach(section => observer.observe(section));
    }

    function initEventCards() {
        if (!domCache.mainEventImage) return;
        domCache.eventCards.forEach(card => {
            card.addEventListener('click', () => {
                domCache.eventCards.forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                const newImageSrc = card.getAttribute('data-image');
                domCache.mainEventImage.style.opacity = 0;
                setTimeout(() => {
                    domCache.mainEventImage.src = newImageSrc;
                    domCache.mainEventImage.style.opacity = 1;
                }, 300);
            });
        });
    }

    // Tratamento de erro para imagens
    function initImageErrorHandling() {
        const images = document.querySelectorAll('img');
        images.forEach(img => {
            img.addEventListener('error', function() {
                // Fallback para imagem quebrada
                this.style.display = 'none';
                
                // Criar elemento de fallback se não existir
                if (!this.nextElementSibling || !this.nextElementSibling.classList.contains('image-fallback')) {
                    const fallback = document.createElement('div');
                    fallback.className = 'image-fallback';
                    const span = document.createElement('span');
                    span.textContent = 'Imagem não disponível';
                    fallback.appendChild(span);
                    fallback.style.cssText = `
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        background: #f3f4f6;
                        color: #6b7280;
                        min-height: 200px;
                        border-radius: 8px;
                        font-size: 14px;
                    `;
                    this.parentNode.insertBefore(fallback, this.nextSibling);
                }
            });
        });
    }
    
    function initModals() {
        let lastFocused = null;
        const focusableSelector = 'a[href], button, input, textarea, select, [tabindex]:not([tabindex="-1"])';
        const trapFocus = (modal) => {
            const focusables = Array.from(modal.querySelectorAll(focusableSelector)).filter(el => !el.hasAttribute('disabled'));
            const firstEl = focusables[0];
            const lastEl = focusables[focusables.length - 1];
            const handleKeyDown = (e) => {
                if (e.key === 'Tab') {
                    if (e.shiftKey && document.activeElement === firstEl) {
                        e.preventDefault();
                        lastEl?.focus();
                    } else if (!e.shiftKey && document.activeElement === lastEl) {
                        e.preventDefault();
                        firstEl?.focus();
                    }
                } else if (e.key === 'Escape') {
                    closeModal(modal);
                }
            };
            modal.addEventListener('keydown', handleKeyDown);
            modal.__cleanupTrap = () => modal.removeEventListener('keydown', handleKeyDown);
            firstEl?.focus();
        };

        const openModal = (modal) => {
            console.log('openModal chamado', modal);
            if (modal) {
                console.log('Modal encontrado, removendo classe hidden');
                lastFocused = document.activeElement;
                modal.classList.remove('hidden');
                modal.classList.add('modal-open');
                document.body.classList.add('modal-open');
                console.log('Classes atualizadas:', modal.classList.toString());
                trapFocus(modal);
            } else {
                console.log('Modal não encontrado!');
            }
        };
        const closeModal = (modal) => {
            if (modal) {
                modal.classList.add('hidden');
                modal.classList.remove('modal-open');
                document.body.classList.remove('modal-open');
                modal.__cleanupTrap?.();
                if (lastFocused && typeof lastFocused.focus === 'function') {
                    lastFocused.focus();
                }
            }
        };

        if (domCache.cadastroModal) {
            console.log('Modal encontrado no DOM:', domCache.cadastroModal);
            const cadastroTriggers = [domCache.openModalBtn, document.getElementById('btn-cadastro-modal-link')].filter(Boolean);
            console.log('Triggers encontrados:', cadastroTriggers);
            cadastroTriggers.forEach(trigger => trigger.addEventListener('click', (e) => {
                console.log('Clique detectado no trigger:', trigger);
                e.preventDefault();
                openModal(domCache.cadastroModal)
            }));
            domCache.closeModalBtn?.addEventListener('click', () => closeModal(domCache.cadastroModal));
            domCache.cadastroModal.addEventListener('click', (e) => {
                if (e.target === domCache.cadastroModal) closeModal(domCache.cadastroModal);
            });
        }
    }

    function initProgressBar() {
        if (!domCache.progressBar) return;
        window.addEventListener('scroll', () => {
            const totalHeight = document.documentElement.scrollHeight - window.innerHeight;
            const progress = (window.scrollY / totalHeight) * 100;
            domCache.progressBar.style.width = `${progress}%`;
        });
    }

    // --- Toggle de Cobrança Mensal/Anual com atualização dinâmica de preços ---
    function initBillingToggle() {
        const toggle = document.querySelector('.billing-toggle');
        const cards = document.querySelectorAll('.plan-card');
        if (!toggle || cards.length === 0) return;

        const buttons = toggle.querySelectorAll('.toggle-btn');

        // Mapeamento de preços (valores atuais conforme conteúdo das páginas)
        const prices = {
            basic: { monthly: 29.90, annualMonthly: 24.92 },
            premium: { monthly: 59.90, annualMonthly: 49.92 },
            enterprise: { monthly: 99.90, annualMonthly: 83.25 }
        };

        const currencyBRL = (v) => v.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });

        const setActiveButton = (mode) => {
            buttons.forEach(b => b.classList.toggle('active', b.dataset.billing === mode));
        };

        const updateMode = (mode) => {
            setActiveButton(mode);
            localStorage.setItem('billingMode', mode);
            cards.forEach(card => {
                const plan = card.getAttribute('data-plan') || card.querySelector('[data-plan]')?.getAttribute('data-plan');
                if (!plan || !prices[plan]) return;

                const monthlyPriceEl = card.querySelector('.monthly-price');
                const annualOptionEl = card.querySelector('.annual-option');
                const planPriceEl = card.querySelector('.plan-price');
                const equivBox = card.querySelector('.equivalent-price');
                const equivStrong = card.querySelector('.equivalent-price strong');
                const savingsEl = card.querySelector('.equivalent-price .savings');

                const monthly = prices[plan].monthly;
                const annualMonthly = prices[plan].annualMonthly;
                const annualTotal = +(annualMonthly * 12).toFixed(2);
                const monthlyTotal = +(monthly * 12).toFixed(2);
                const savings = +(monthlyTotal - annualTotal).toFixed(2);

                if (mode === 'monthly') {
                    if (monthlyPriceEl) monthlyPriceEl.textContent = `${currencyBRL(monthly)}/mês`;
                    if (annualOptionEl) annualOptionEl.textContent = `ou ${currencyBRL(annualTotal)}/ano`;
                    if (planPriceEl) planPriceEl.innerHTML = `<span class="currency">R$</span>${monthly.toFixed(2).replace('.', ',')}<span class="period">/mês</span>`;
                    if (equivBox) equivBox.style.display = 'none';
                } else {
                    if (monthlyPriceEl) monthlyPriceEl.textContent = `${currencyBRL(annualTotal)}/ano`;
                    if (annualOptionEl) annualOptionEl.textContent = `ou ${currencyBRL(monthly)}/mês`;
                    if (planPriceEl) planPriceEl.innerHTML = `<span class="currency">R$</span>${annualTotal.toFixed(2).replace('.', ',')}<span class="period">/ano</span>`;
                    if (equivBox) {
                        equivBox.style.display = '';
                        if (equivStrong) equivStrong.textContent = `${currencyBRL(annualMonthly)}/mês`;
                        if (savingsEl) savingsEl.textContent = `Economize 17% pagando anualmente`;
                    }
                }
            });
        };

        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.billing === 'annual' ? 'annual' : 'monthly';
                updateMode(mode);
            });
        });

        // Inicializa com prioridade: query param > localStorage > monthly
        const urlParams = new URLSearchParams(window.location.search);
        const paramMode = urlParams.get('billing');
        const storedMode = localStorage.getItem('billingMode');
        const initialMode = (paramMode === 'annual' || paramMode === 'monthly') ? paramMode : (storedMode || 'monthly');
        updateMode(initialMode);
    }

    // Validação client-side aprimorada
    function initFormValidation() {
        const form = document.getElementById('contact-form');
        if (!form) return;

        const validators = {
            nome: (value) => {
                if (!value.trim()) return 'Nome é obrigatório';
                if (value.trim().length < 2) return 'Nome deve ter pelo menos 2 caracteres';
                if (!/^[a-zA-ZÀ-ÿ\s]+$/.test(value)) return 'Nome deve conter apenas letras';
                return null;
            },
            email: (value) => {
                if (!value.trim()) return 'E-mail é obrigatório';
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(value)) return 'E-mail inválido';
                return null;
            },
            telefone: (value) => {
                if (value && !/^[\d\s\(\)\-\+]+$/.test(value)) return 'Telefone inválido';
                return null;
            },
            mensagem: (value) => {
                if (!value.trim()) return 'Mensagem é obrigatória';
                if (value.trim().length < 10) return 'Mensagem deve ter pelo menos 10 caracteres';
                return null;
            }
        };

        const showError = (fieldName, message) => {
            const errorEl = document.getElementById(`${fieldName}-error`);
            const field = document.querySelector(`[name="${fieldName}"]`);
            if (errorEl && field) {
                errorEl.textContent = message;
                errorEl.classList.add('show');
                field.parentElement.classList.add('error');
            }
        };

        const clearError = (fieldName) => {
            const errorEl = document.getElementById(`${fieldName}-error`);
            const field = document.querySelector(`[name="${fieldName}"]`);
            if (errorEl && field) {
                errorEl.textContent = '';
                errorEl.classList.remove('show');
                field.parentElement.classList.remove('error');
            }
        };

        const validateField = (fieldName, value) => {
            const validator = validators[fieldName];
            if (!validator) return true;
            
            const error = validator(value);
            if (error) {
                showError(fieldName, error);
                return false;
            } else {
                clearError(fieldName);
                return true;
            }
        };

        // Validação em tempo real
        Object.keys(validators).forEach(fieldName => {
            const field = document.querySelector(`[name="${fieldName}"]`);
            if (field) {
                field.addEventListener('blur', () => {
                    validateField(fieldName, field.value);
                });
                field.addEventListener('input', () => {
                    if (field.parentElement.classList.contains('error')) {
                        validateField(fieldName, field.value);
                    }
                });
            }
        });

        return { validateField, clearError };
    }

    // Interceptar envio do formulário de contato para integração com API
    function initContactForm() {
        const form = document.getElementById('contact-form');
        if (!form) return;
        
        const { validateField, clearError } = initFormValidation();
        const submitBtn = form.querySelector('button[type="submit"]');
        const feedback = document.getElementById('contact-feedback');
        
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Limpar erros anteriores
            ['nome', 'email', 'telefone', 'mensagem'].forEach(clearError);
            
            const formData = new FormData(form);
            const payload = {
                nome: formData.get('nome')?.toString().trim() || '',
                email: formData.get('email')?.toString().trim() || '',
                telefone: formData.get('telefone')?.toString().trim() || '',
                mensagem: formData.get('mensagem')?.toString().trim() || '',
                website: formData.get('website')?.toString().trim() || '' // honeypot
            };

            // Validar todos os campos
            let isValid = true;
            Object.keys(payload).forEach(fieldName => {
                if (fieldName !== 'website') {
                    if (!validateField(fieldName, payload[fieldName])) {
                        isValid = false;
                    }
                }
            });

            if (!isValid) {
                if (feedback) {
                    feedback.textContent = 'Por favor, corrija os erros acima.';
                    feedback.style.color = 'var(--cor-erro)';
                }
                return;
            }

            submitBtn.disabled = true;
            submitBtn.classList.add('loading');
            if (feedback) { 
                feedback.textContent = 'Enviando...';
                feedback.style.color = 'var(--cor-texto-geral)';
            }
            
            try {
                const res = await fetch('/api/contact', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                if (res.ok) {
                    if (feedback) { 
                        feedback.textContent = 'Mensagem enviada com sucesso!';
                        feedback.style.color = 'var(--cor-sucesso)';
                    }
                    form.reset();
                } else {
                    const msg = data?.message || 'Erro ao enviar sua mensagem.';
                    if (feedback) { 
                        feedback.textContent = msg;
                        feedback.style.color = 'var(--cor-erro)';
                    }
                }
            } catch (err) {
                if (feedback) { 
                    feedback.textContent = 'Falha de rede. Tente novamente.';
                    feedback.style.color = 'var(--cor-erro)';
                }
            } finally {
                submitBtn.disabled = false;
                submitBtn.classList.remove('loading');
            }
        });
    }

    init();
    initContactForm();
});

/* === realtime-client.js === */
/**
 * CLIENTE WEBSOCKET PARA NOTIFICAÇÕES EM TEMPO REAL
 * 
 * Este cliente gerencia a conexão WebSocket com o servidor,
 * processa notificações em tempo real e mantém sincronização
 * com a interface do usuário.
 * 
 * Funcionalidades:
 * - Conexão automática com reconexão
 * - Autenticação via JWT
 * - Processamento de notificações
 * - Interface com UI
 * - Fallback para polling
 * 
 * @author Sistema Kanghoo
 * @version 1.0.0
 */

class RealtimeClient {
    constructor(options = {}) {
        this.options = {
            serverUrl: options.serverUrl || 'ws://localhost:8080/ws',
            reconnectInterval: options.reconnectInterval || 5000,
            maxReconnectAttempts: options.maxReconnectAttempts || 10,
            heartbeatInterval: options.heartbeatInterval || 30000,
            enableFallback: options.enableFallback !== false,
            fallbackInterval: options.fallbackInterval || 30000,
            debug: options.debug || false,
            ...options
        };

        // Estado da conexão
        this.ws = null;
        this.isConnected = false;
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.lastHeartbeat = null;

        // Autenticação
        this.authToken = null;
        this.userData = null;

        // Event listeners
        this.eventListeners = new Map();
        
        // Timers
        this.reconnectTimer = null;
        this.heartbeatTimer = null;
        this.fallbackTimer = null;

        // Estatísticas
        this.stats = {
            connectionsAttempted: 0,
            connectionsSuccessful: 0,
            messagesReceived: 0,
            messagesSent: 0,
            reconnections: 0,
            errors: 0
        };

        // Fallback para polling
        this.fallbackActive = false;
        this.lastPollingUpdate = null;

        console.log('[REALTIME-CLIENT] Cliente de notificações inicializado');
    }

    /**
     * Inicializa o cliente
     */
    async initialize(authToken) {
        try {
            this.authToken = authToken;
            
            // Verificar suporte a WebSocket
            if (!this.isWebSocketSupported()) {
                console.warn('[REALTIME-CLIENT] WebSocket não suportado, usando fallback');
                if (this.options.enableFallback) {
                    this.startFallbackPolling();
                }
                return false;
            }

            // Conectar ao servidor
            await this.connect();
            
            // Configurar heartbeat
            this.startHeartbeat();

            return true;

        } catch (error) {
            console.error('[REALTIME-CLIENT] Erro na inicialização:', error);
            this.stats.errors++;
            return false;
        }
    }

    /**
     * Conecta ao servidor WebSocket
     */
    async connect() {
        if (this.isConnecting || this.isConnected) {
            return;
        }

        try {
            this.isConnecting = true;
            this.stats.connectionsAttempted++;

            console.log('[REALTIME-CLIENT] Conectando ao servidor...');

            // Construir URL com token
            const wsUrl = `${this.options.serverUrl}?token=${encodeURIComponent(this.authToken)}`;
            
            // Criar conexão WebSocket
            this.ws = new WebSocket(wsUrl);

            // Configurar event listeners
            this.setupWebSocketListeners();

            // Aguardar conexão ou timeout
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Timeout na conexão'));
                }, 10000);

                this.ws.onopen = () => {
                    clearTimeout(timeout);
                    resolve();
                };

                this.ws.onerror = (error) => {
                    clearTimeout(timeout);
                    reject(error);
                };
            });

        } catch (error) {
            this.isConnecting = false;
            throw error;
        }
    }

    /**
     * Configura listeners do WebSocket
     */
    setupWebSocketListeners() {
        this.ws.onopen = () => {
            console.log('[REALTIME-CLIENT] Conectado ao servidor');
            
            this.isConnected = true;
            this.isConnecting = false;
            this.reconnectAttempts = 0;
            this.stats.connectionsSuccessful++;

            // Parar fallback se estiver ativo
            this.stopFallbackPolling();

            // Emitir evento de conexão
            this.emit('connected');

            // Enviar mensagem de identificação
            this.sendIdentification();
        };

        this.ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                this.handleMessage(message);
                this.stats.messagesReceived++;
            } catch (error) {
                console.error('[REALTIME-CLIENT] Erro ao processar mensagem:', error);
                this.stats.errors++;
            }
        };

        this.ws.onclose = (event) => {
            console.log(`[REALTIME-CLIENT] Conexão fechada: ${event.code} - ${event.reason}`);
            
            this.isConnected = false;
            this.isConnecting = false;

            // Emitir evento de desconexão
            this.emit('disconnected', { code: event.code, reason: event.reason });

            // Tentar reconectar se não foi fechamento intencional
            if (event.code !== 1000 && this.reconnectAttempts < this.options.maxReconnectAttempts) {
                this.scheduleReconnect();
            } else if (this.options.enableFallback) {
                this.startFallbackPolling();
            }
        };

        this.ws.onerror = (error) => {
            console.error('[REALTIME-CLIENT] Erro na conexão WebSocket:', error);
            this.stats.errors++;
            this.emit('error', error);
        };

        this.ws.onpong = () => {
            this.lastHeartbeat = new Date();
            if (this.options.debug) {
                console.log('[REALTIME-CLIENT] Pong recebido');
            }
        };
    }

    /**
     * Processa mensagens recebidas
     */
    handleMessage(message) {
        if (this.options.debug) {
            console.log('[REALTIME-CLIENT] Mensagem recebida:', message);
        }

        switch (message.type) {
            case 'notification':
                this.handleNotification(message.data);
                break;

            case 'system':
                this.handleSystemMessage(message.data);
                break;

            case 'auth_success':
                this.handleAuthSuccess(message.data);
                break;

            case 'auth_failed':
                this.handleAuthFailed(message.data);
                break;

            case 'ping':
                this.sendPong();
                break;

            default:
                console.warn('[REALTIME-CLIENT] Tipo de mensagem desconhecido:', message.type);
        }

        // Emitir evento genérico
        this.emit('message', message);
    }

    /**
     * Processa notificações
     */
    handleNotification(notification) {
        console.log('[REALTIME-CLIENT] Nova notificação:', notification);

        // Emitir evento específico do tipo de notificação
        this.emit(`notification:${notification.type}`, notification);
        
        // Emitir evento genérico de notificação
        this.emit('notification', notification);

        // Mostrar notificação na UI
        this.showNotificationInUI(notification);

        // Reproduzir som se configurado
        this.playNotificationSound(notification);

        // Salvar no histórico local
        this.saveNotificationToHistory(notification);
    }

    /**
     * Processa mensagens do sistema
     */
    handleSystemMessage(data) {
        console.log('[REALTIME-CLIENT] Mensagem do sistema:', data);

        switch (data.action) {
            case 'maintenance':
                this.emit('maintenance', data);
                break;

            case 'force_disconnect':
                this.disconnect();
                break;

            case 'update_available':
                this.emit('update_available', data);
                break;
        }
    }

    /**
     * Processa sucesso na autenticação
     */
    handleAuthSuccess(data) {
        console.log('[REALTIME-CLIENT] Autenticação bem-sucedida');
        this.userData = data.user;
        this.emit('auth_success', data);
    }

    /**
     * Processa falha na autenticação
     */
    handleAuthFailed(data) {
        console.error('[REALTIME-CLIENT] Falha na autenticação:', data.error);
        this.emit('auth_failed', data);
        this.disconnect();
    }

    /**
     * Envia identificação inicial
     */
    sendIdentification() {
        const identification = {
            type: 'identify',
            data: {
                userAgent: navigator.userAgent,
                timestamp: new Date(),
                capabilities: {
                    notifications: 'Notification' in window,
                    audio: 'Audio' in window,
                    vibration: 'vibrate' in navigator
                }
            }
        };

        this.send(identification);
    }

    /**
     * Envia mensagem via WebSocket
     */
    send(message) {
        if (!this.isConnected || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
            console.warn('[REALTIME-CLIENT] Tentativa de enviar mensagem sem conexão ativa');
            return false;
        }

        try {
            this.ws.send(JSON.stringify(message));
            this.stats.messagesSent++;
            return true;
        } catch (error) {
            console.error('[REALTIME-CLIENT] Erro ao enviar mensagem:', error);
            this.stats.errors++;
            return false;
        }
    }

    /**
     * Envia pong em resposta ao ping
     */
    sendPong() {
        this.send({ type: 'pong', timestamp: new Date() });
    }

    /**
     * Agenda reconexão
     */
    scheduleReconnect() {
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
        }

        this.reconnectAttempts++;
        const delay = Math.min(
            this.options.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1),
            30000 // Máximo 30 segundos
        );

        console.log(`[REALTIME-CLIENT] Tentativa de reconexão ${this.reconnectAttempts}/${this.options.maxReconnectAttempts} em ${delay}ms`);

        this.reconnectTimer = setTimeout(async () => {
            try {
                await this.connect();
                this.stats.reconnections++;
            } catch (error) {
                console.error('[REALTIME-CLIENT] Falha na reconexão:', error);
            }
        }, delay);
    }

    /**
     * Inicia heartbeat
     */
    startHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
        }

        this.heartbeatTimer = setInterval(() => {
            if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                this.ws.ping();
                
                // Verificar se o último heartbeat foi há muito tempo
                if (this.lastHeartbeat) {
                    const timeSinceLastHeartbeat = Date.now() - this.lastHeartbeat.getTime();
                    if (timeSinceLastHeartbeat > this.options.heartbeatInterval * 2) {
                        console.warn('[REALTIME-CLIENT] Heartbeat perdido, reconectando...');
                        this.disconnect();
                        this.scheduleReconnect();
                    }
                }
            }
        }, this.options.heartbeatInterval);
    }

    /**
     * Inicia polling de fallback
     */
    startFallbackPolling() {
        if (!this.options.enableFallback || this.fallbackActive) {
            return;
        }

        console.log('[REALTIME-CLIENT] Iniciando polling de fallback');
        this.fallbackActive = true;

        this.fallbackTimer = setInterval(async () => {
            try {
                await this.pollForUpdates();
            } catch (error) {
                console.error('[REALTIME-CLIENT] Erro no polling de fallback:', error);
            }
        }, this.options.fallbackInterval);

        this.emit('fallback_started');
    }

    /**
     * Para polling de fallback
     */
    stopFallbackPolling() {
        if (this.fallbackTimer) {
            clearInterval(this.fallbackTimer);
            this.fallbackTimer = null;
        }

        if (this.fallbackActive) {
            this.fallbackActive = false;
            console.log('[REALTIME-CLIENT] Polling de fallback parado');
            this.emit('fallback_stopped');
        }
    }

    /**
     * Faz polling para atualizações (fallback)
     */
    async pollForUpdates() {
        try {
            const response = await fetch('/api/notifications/poll', {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${this.authToken}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const data = await response.json();
                
                if (data.notifications && data.notifications.length > 0) {
                    data.notifications.forEach(notification => {
                        this.handleNotification(notification);
                    });
                }

                this.lastPollingUpdate = new Date();
            }

        } catch (error) {
            console.error('[REALTIME-CLIENT] Erro no polling:', error);
        }
    }

    /**
     * Mostra notificação na UI
     */
    showNotificationInUI(notification) {
        // Criar elemento de notificação
        const notificationElement = this.createNotificationElement(notification);
        
        // Adicionar à área de notificações
        const notificationsContainer = document.getElementById('notifications-container');
        if (notificationsContainer) {
            notificationsContainer.appendChild(notificationElement);
            
            // Auto-remover após alguns segundos
            setTimeout(() => {
                if (notificationElement.parentNode) {
                    notificationElement.remove();
                }
            }, 5000);
        }

        // Mostrar notificação do browser se permitido
        this.showBrowserNotification(notification);

        // Atualizar badge/contador
        this.updateNotificationBadge();
    }

    /**
     * Cria elemento HTML da notificação
     */
    createNotificationElement(notification) {
        const div = document.createElement('div');
        div.className = `notification notification-${notification.priority}`;
        div.innerHTML = `
            <div class="notification-header">
                <span class="notification-type">${this.getNotificationTypeLabel(notification.type)}</span>
                <span class="notification-time">${this.formatTime(notification.timestamp)}</span>
                <button class="notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
            </div>
            <div class="notification-content">
                <p>${notification.data.message}</p>
            </div>
        `;
        return div;
    }

    /**
     * Mostra notificação do browser
     */
    showBrowserNotification(notification) {
        if ('Notification' in window && Notification.permission === 'granted') {
            const browserNotification = new Notification(
                this.getNotificationTypeLabel(notification.type),
                {
                    body: notification.data.message,
                    icon: '/images/kanghoo-icon.png',
                    tag: notification.type,
                    requireInteraction: notification.priority === 'critical'
                }
            );

            // Auto-fechar após 5 segundos (exceto críticas)
            if (notification.priority !== 'critical') {
                setTimeout(() => browserNotification.close(), 5000);
            }
        }
    }

    /**
     * Reproduz som de notificação
     */
    playNotificationSound(notification) {
        if ('Audio' in window) {
            try {
                const audio = new Audio(`/sounds/notification-${notification.priority}.mp3`);
                audio.volume = 0.5;
                audio.play().catch(() => {
                    // Ignorar erro se não conseguir reproduzir
                });
            } catch (error) {
                // Ignorar erro de áudio
            }
        }

        // Vibração para dispositivos móveis
        if ('vibrate' in navigator && notification.priority === 'critical') {
            navigator.vibrate([200, 100, 200]);
        }
    }

    /**
     * Salva notificação no histórico local
     */
    saveNotificationToHistory(notification) {
        try {
            const history = JSON.parse(localStorage.getItem('notification_history') || '[]');
            history.unshift({
                ...notification,
                receivedAt: new Date()
            });

            // Manter apenas as últimas 100 notificações
            if (history.length > 100) {
                history.splice(100);
            }

            localStorage.setItem('notification_history', JSON.stringify(history));
        } catch (error) {
            console.error('[REALTIME-CLIENT] Erro ao salvar histórico:', error);
        }
    }

    /**
     * Atualiza badge de notificações
     */
    updateNotificationBadge() {
        const badge = document.getElementById('notification-badge');
        if (badge) {
            const unreadCount = this.getUnreadNotificationsCount();
            badge.textContent = unreadCount > 0 ? unreadCount : '';
            badge.style.display = unreadCount > 0 ? 'block' : 'none';
        }
    }

    /**
     * Obtém contagem de notificações não lidas
     */
    getUnreadNotificationsCount() {
        try {
            const history = JSON.parse(localStorage.getItem('notification_history') || '[]');
            return history.filter(n => !n.read).length;
        } catch (error) {
            return 0;
        }
    }

    /**
     * Adiciona listener de evento
     */
    on(event, callback) {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event).push(callback);
    }

    /**
     * Remove listener de evento
     */
    off(event, callback) {
        if (this.eventListeners.has(event)) {
            const listeners = this.eventListeners.get(event);
            const index = listeners.indexOf(callback);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }

    /**
     * Emite evento
     */
    emit(event, data) {
        if (this.eventListeners.has(event)) {
            this.eventListeners.get(event).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`[REALTIME-CLIENT] Erro no listener de ${event}:`, error);
                }
            });
        }
    }

    /**
     * Desconecta do servidor
     */
    disconnect() {
        if (this.ws) {
            this.ws.close(1000, 'Desconexão intencional');
        }

        // Limpar timers
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }

        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }

        this.stopFallbackPolling();

        this.isConnected = false;
        this.isConnecting = false;
    }

    /**
     * Verifica suporte a WebSocket
     */
    isWebSocketSupported() {
        return 'WebSocket' in window;
    }

    /**
     * Obtém label do tipo de notificação
     */
    getNotificationTypeLabel(type) {
        const labels = {
            'crianca_embarcou': 'Embarque',
            'crianca_desembarcou': 'Desembarque',
            'veiculo_chegando': 'Chegada',
            'atraso_detectado': 'Atraso',
            'emergencia': 'Emergência',
            'nova_mensagem': 'Mensagem',
            'pagamento_aprovado': 'Pagamento'
        };
        return labels[type] || 'Notificação';
    }

    /**
     * Formata timestamp
     */
    formatTime(timestamp) {
        return new Date(timestamp).toLocaleTimeString('pt-BR', {
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    /**
     * Obtém estatísticas do cliente
     */
    getStats() {
        return {
            ...this.stats,
            isConnected: this.isConnected,
            reconnectAttempts: this.reconnectAttempts,
            fallbackActive: this.fallbackActive,
            lastHeartbeat: this.lastHeartbeat,
            lastPollingUpdate: this.lastPollingUpdate
        };
    }

    /**
     * Solicita permissão para notificações do browser
     */
    async requestNotificationPermission() {
        if ('Notification' in window) {
            const permission = await Notification.requestPermission();
            return permission === 'granted';
        }
        return false;
    }
}

// Exportar para uso global
window.RealtimeClient = RealtimeClient;

/* === cache-manager.js === */
/**
 * Sistema de Cache Otimizado para Ambiente de Teste
 * Melhora performance através de cache inteligente de recursos e dados
 */

class CacheManager {
    constructor() {
        this.memoryCache = new Map();
        this.storagePrefix = 'kanghoo_cache_';
        this.defaultTTL = 5 * 60 * 1000; // 5 minutos
        this.maxMemoryItems = 100;
        this.isTestEnvironment = this.detectTestEnvironment();
        
        this.initializeCache();
        this.setupPeriodicCleanup();
    }

    detectTestEnvironment() {
        return window.location.hostname === 'localhost' || 
               window.location.hostname === '127.0.0.1' ||
               window.location.port === '5000';
    }

    initializeCache() {
        // Limpar cache expirado no localStorage
        this.cleanExpiredLocalStorage();
        
        // Configurar interceptadores para recursos estáticos
        if (this.isTestEnvironment) {
            this.setupResourceInterceptors();
        }
    }

    setupResourceInterceptors() {
        // Interceptar carregamento de imagens
        const originalCreateElement = document.createElement;
        document.createElement = function(tagName) {
            const element = originalCreateElement.call(this, tagName);
            
            if (tagName.toLowerCase() === 'img') {
                const originalSetSrc = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src').set;
                Object.defineProperty(element, 'src', {
                    set: function(value) {
                        // Cache de imagens
                        window.cacheManager.cacheResource(value, 'image');
                        originalSetSrc.call(this, value);
                    },
                    get: function() {
                        return this.getAttribute('src');
                    }
                });
            }
            
            return element;
        };
    }

    // Cache de dados com TTL
    set(key, data, ttl = this.defaultTTL) {
        const cacheItem = {
            data: data,
            timestamp: Date.now(),
            ttl: ttl,
            expires: Date.now() + ttl
        };

        // Cache em memória (mais rápido)
        if (this.memoryCache.size >= this.maxMemoryItems) {
            this.evictOldestMemoryItem();
        }
        this.memoryCache.set(key, cacheItem);

        // Cache persistente para dados importantes
        if (this.shouldPersist(key)) {
            try {
                localStorage.setItem(
                    this.storagePrefix + key, 
                    JSON.stringify(cacheItem)
                );
            } catch (e) {
                console.warn('Cache: Falha ao salvar no localStorage:', e);
            }
        }
    }

    get(key) {
        // Tentar cache em memória primeiro
        let cacheItem = this.memoryCache.get(key);
        
        // Se não encontrou em memória, tentar localStorage
        if (!cacheItem && this.shouldPersist(key)) {
            try {
                const stored = localStorage.getItem(this.storagePrefix + key);
                if (stored) {
                    cacheItem = JSON.parse(stored);
                    // Recarregar em memória
                    this.memoryCache.set(key, cacheItem);
                }
            } catch (e) {
                console.warn('Cache: Falha ao ler do localStorage:', e);
            }
        }

        if (!cacheItem) {
            return null;
        }

        // Verificar expiração
        if (Date.now() > cacheItem.expires) {
            this.delete(key);
            return null;
        }

        // Atualizar timestamp de acesso
        cacheItem.lastAccess = Date.now();
        
        return cacheItem.data;
    }

    delete(key) {
        this.memoryCache.delete(key);
        localStorage.removeItem(this.storagePrefix + key);
    }

    clear() {
        this.memoryCache.clear();
        
        // Limpar apenas itens do cache no localStorage
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.storagePrefix)) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
    }

    // Cache específico para dados de API
    async cacheApiCall(url, fetchOptions = {}, ttl = this.defaultTTL) {
        const cacheKey = this.generateApiCacheKey(url, fetchOptions);
        
        // Tentar cache primeiro
        const cached = this.get(cacheKey);
        if (cached) {
            return cached;
        }

        // Se não tem cache, fazer requisição
        try {
            const response = await fetch(url, fetchOptions);
            const data = await response.json();
            
            if (response.ok) {
                this.set(cacheKey, data, ttl);
            }
            
            return data;
        } catch (error) {
            console.error('Cache: Erro na requisição API:', error);
            throw error;
        }
    }

    // Cache para recursos estáticos
    cacheResource(url, type = 'unknown') {
        const cacheKey = `resource_${type}_${url}`;
        
        if (!this.get(cacheKey)) {
            this.set(cacheKey, {
                url: url,
                type: type,
                cached: Date.now()
            }, 30 * 60 * 1000); // 30 minutos para recursos
        }
    }

    // Cache para dados de usuário
    cacheUserData(userData, ttl = 60 * 60 * 1000) { // 1 hora
        this.set('user_data', userData, ttl);
    }

    getUserData() {
        return this.get('user_data');
    }

    // Cache para dados de viagem
    cacheViagemData(viagemData, ttl = 2 * 60 * 1000) { // 2 minutos
        this.set('viagem_ativa', viagemData, ttl);
    }

    getViagemData() {
        return this.get('viagem_ativa');
    }

    // Cache para estatísticas
    cacheEstatisticas(stats, ttl = 10 * 60 * 1000) { // 10 minutos
        this.set('estatisticas', stats, ttl);
    }

    getEstatisticas() {
        return this.get('estatisticas');
    }

    // Métodos auxiliares
    generateApiCacheKey(url, options) {
        const method = options.method || 'GET';
        const body = options.body || '';
        return `api_${method}_${url}_${this.hashString(body)}`;
    }

    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash.toString(36);
    }

    shouldPersist(key) {
        const persistentKeys = [
            'user_data', 
            'estatisticas', 
            'configuracoes',
            'theme_preference'
        ];
        return persistentKeys.some(persistentKey => key.includes(persistentKey));
    }

    evictOldestMemoryItem() {
        let oldestKey = null;
        let oldestTime = Date.now();

        for (const [key, item] of this.memoryCache.entries()) {
            const accessTime = item.lastAccess || item.timestamp;
            if (accessTime < oldestTime) {
                oldestTime = accessTime;
                oldestKey = key;
            }
        }

        if (oldestKey) {
            this.memoryCache.delete(oldestKey);
        }
    }

    cleanExpiredLocalStorage() {
        const keysToRemove = [];
        
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.storagePrefix)) {
                try {
                    const item = JSON.parse(localStorage.getItem(key));
                    if (item.expires && Date.now() > item.expires) {
                        keysToRemove.push(key);
                    }
                } catch (e) {
                    // Item corrompido, remover
                    keysToRemove.push(key);
                }
            }
        }

        keysToRemove.forEach(key => localStorage.removeItem(key));
    }

    setupPeriodicCleanup() {
        // Limpeza a cada 5 minutos
        setInterval(() => {
            this.cleanExpiredLocalStorage();
            
            // Limpar itens expirados da memória
            for (const [key, item] of this.memoryCache.entries()) {
                if (Date.now() > item.expires) {
                    this.memoryCache.delete(key);
                }
            }
        }, 5 * 60 * 1000);
    }

    // Estatísticas do cache
    getStats() {
        return {
            memoryItems: this.memoryCache.size,
            localStorageItems: this.getLocalStorageItemCount(),
            memorySize: this.estimateMemorySize(),
            lastCleanup: this.lastCleanup || 'Nunca'
        };
    }

    getLocalStorageItemCount() {
        let count = 0;
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.storagePrefix)) {
                count++;
            }
        }
        return count;
    }

    estimateMemorySize() {
        let size = 0;
        for (const [key, value] of this.memoryCache.entries()) {
            size += key.length + JSON.stringify(value).length;
        }
        return `${(size / 1024).toFixed(2)} KB`;
    }

    // Pré-carregar dados importantes
    async preloadCriticalData() {
        if (!this.isTestEnvironment) return;

        const criticalEndpoints = [
            '/api/rastreamento/viagem-ativa',
            '/api/rastreamento/estatisticas'
        ];

        const preloadPromises = criticalEndpoints.map(endpoint => 
            this.cacheApiCall(endpoint).catch(e => 
                console.warn(`Preload falhou para ${endpoint}:`, e)
            )
        );

        await Promise.allSettled(preloadPromises);
    }
}

// Inicializar automaticamente
window.cacheManager = new CacheManager();

// Pré-carregar dados críticos quando a página carregar
document.addEventListener('DOMContentLoaded', () => {
    window.cacheManager.preloadCriticalData();
});

// Exportar para uso em módulos
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CacheManager;
}

/* === formulario-multiplas-etapas.js === */
class MultiStepForm {
    constructor(formId, steps) {
        this.form = document.getElementById(formId);
        this.steps = steps;
        this.currentStep = 0;
        this.totalSteps = steps.length;
        
        this.init();
    }

    // Função de sanitização para prevenir XSS
    sanitizeHTML(str) {
        const temp = document.createElement('div');
        temp.textContent = str;
        return temp.innerHTML;
    }

    // Criar elemento de forma segura
    createSafeElement(tag, textContent = '', className = '') {
        const element = document.createElement(tag);
        if (textContent) element.textContent = textContent;
        if (className) element.className = className;
        return element;
    }
    
    init() {
        this.createProgressBar();
        this.setupSteps();
        this.setupNavigation();
        this.setupKeyboardNavigation();
        this.showStep(0);
        this.updateProgress();
    }
    
    createProgressBar() {
        const progressContainer = document.createElement('div');
        progressContainer.className = 'progress-container';
        
        const progressBar = document.createElement('div');
        progressBar.className = 'progress-bar';
        
        const progressLine = document.createElement('div');
        progressLine.className = 'progress-line';
        
        const progressLineFill = document.createElement('div');
        progressLineFill.className = 'progress-line-fill';
        progressLine.appendChild(progressLineFill);
        
        progressBar.appendChild(progressLine);
        
        // Create step indicators
        this.steps.forEach((step, index) => {
            const indicator = document.createElement('div');
            indicator.className = 'step-indicator';
            indicator.textContent = index + 1;
            indicator.addEventListener('click', () => this.goToStep(index));
            progressBar.appendChild(indicator);
        });
        
        progressContainer.appendChild(progressBar);
        
        // Create step labels
        const stepLabels = document.createElement('div');
        stepLabels.className = 'step-labels';
        
        this.steps.forEach(step => {
            const label = document.createElement('div');
            label.className = 'step-label';
            label.textContent = step.title;
            stepLabels.appendChild(label);
        });
        
        progressContainer.appendChild(stepLabels);
        
        // Insert before form
        this.form.parentNode.insertBefore(progressContainer, this.form);
    }
    
    setupSteps() {
        this.steps.forEach((step, index) => {
            const stepElement = document.querySelector(step.selector);
            if (stepElement) {
                stepElement.classList.add('form-step');
                stepElement.setAttribute('data-step', index);
                
                // Salvar conteúdo original
                const originalContent = Array.from(stepElement.children);
                
                // Limpar elemento
                stepElement.innerHTML = '';
                
                // Criar wrapper seguro
                const stepContent = this.createSafeElement('div', '', 'step-content');
                
                // Criar título
                const title = this.createSafeElement('h2', step.title, 'step-title');
                stepContent.appendChild(title);
                
                // Criar descrição
                const description = this.createSafeElement('p', step.description, 'step-description');
                stepContent.appendChild(description);
                
                // Adicionar conteúdo original
                originalContent.forEach(child => stepContent.appendChild(child));
                
                // Criar navegação
                const navigation = this.createSafeElement('div', '', 'step-navigation');
                
                // Botão anterior
                const prevBtn = this.createSafeElement('button', '← Anterior', 'btn-step btn-prev');
                prevBtn.type = 'button';
                if (index === 0) prevBtn.style.visibility = 'hidden';
                navigation.appendChild(prevBtn);
                
                // Botão próximo
                const nextBtnText = index === this.totalSteps - 1 ? 'Finalizar' : 'Próximo →';
                const nextBtn = this.createSafeElement('button', nextBtnText, 'btn-step btn-next');
                nextBtn.type = 'button';
                navigation.appendChild(nextBtn);
                
                stepContent.appendChild(navigation);
                stepElement.appendChild(stepContent);
            }
        });
    }
    
    setupNavigation() {
        this.form.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn-next')) {
                e.preventDefault();
                this.nextStep();
            } else if (e.target.classList.contains('btn-prev')) {
                e.preventDefault();
                this.prevStep();
            } else if (e.target.classList.contains('btn-submit')) {
                e.preventDefault();
                this.submitForm();
            }
        });
        
        // Adicionar listeners para atualizar progresso em tempo real
        this.form.addEventListener('input', () => {
            // Debounce para evitar muitas atualizações
            clearTimeout(this.progressUpdateTimeout);
            this.progressUpdateTimeout = setTimeout(() => {
                this.updateProgressDetails();
            }, 300);
        });
        
        this.form.addEventListener('change', () => {
            this.updateProgressDetails();
        });
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey) {
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    this.nextStep();
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    this.prevStep();
                }
            }
        });
    }
    
    setupKeyboardNavigation() {
        document.addEventListener('keydown', (e) => {
            // Only handle keyboard navigation if focus is within the form
            if (!this.form.contains(document.activeElement)) return;
            
            switch(e.key) {
                case 'ArrowRight':
                case 'PageDown':
                    e.preventDefault();
                    this.nextStep();
                    break;
                case 'ArrowLeft':
                case 'PageUp':
                    e.preventDefault();
                    this.prevStep();
                    break;
                case 'Home':
                    e.preventDefault();
                    this.showStep(0, this.currentStep > 0 ? 'backward' : 'forward');
                    break;
                case 'End':
                    e.preventDefault();
                    const lastStep = this.totalSteps - 1;
                    this.showStep(lastStep, this.currentStep < lastStep ? 'forward' : 'backward');
                    break;
            }
        });
    }
    
    showStep(stepIndex, direction = 'forward') {
        const steps = document.querySelectorAll('.form-step');
        const currentStepElement = steps[this.currentStep];
        const nextStepElement = steps[stepIndex];
        
        // Hide current step with animation
        if (currentStepElement && this.currentStep !== stepIndex) {
            currentStepElement.classList.remove('active');
            currentStepElement.classList.add(direction === 'forward' ? 'next' : 'prev');
            
            setTimeout(() => {
                currentStepElement.style.display = 'none';
                currentStepElement.classList.remove('next', 'prev');
            }, 400);
        }
        
        // Show new step with animation
        if (nextStepElement) {
            nextStepElement.style.display = 'block';
            nextStepElement.classList.remove('next', 'prev');
            
            // Add appropriate entering animation class
            if (direction === 'forward') {
                nextStepElement.classList.add('active');
            } else {
                nextStepElement.classList.add('active', 'entering-left');
            }
            
            // Remove entering animation class after animation completes
            setTimeout(() => {
                nextStepElement.classList.remove('entering-left');
            }, 800);
        }
        
        this.currentStep = stepIndex;
        this.updateProgress();
        this.updateStepIndicators();
        this.scrollToTop();
        
        // Add subtle page vibration effect
        this.addPageTransitionEffect();
    }
    
    nextStep() {
        if (this.validateCurrentStep()) {
            if (this.currentStep < this.totalSteps - 1) {
                this.showStep(this.currentStep + 1, 'forward');
            }
        }
    }
    
    prevStep() {
        if (this.currentStep > 0) {
            this.showStep(this.currentStep - 1, 'backward');
        }
    }
    
    goToStep(stepIndex) {
        // Only allow going to previous steps or next step if current is valid
        if (stepIndex <= this.currentStep || 
            (stepIndex === this.currentStep + 1 && this.validateCurrentStep())) {
            this.showStep(stepIndex);
        }
    }
    
    updateProgress() {
        const progressFill = document.querySelector('.progress-line-fill');
        const percentage = (this.currentStep / (this.totalSteps - 1)) * 100;
        
        // Animate progress bar with custom CSS variable
        progressFill.style.setProperty('--target-width', `${percentage}%`);
        progressFill.style.animation = 'progressFill 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards';
        
        setTimeout(() => {
            progressFill.style.width = `${percentage}%`;
            progressFill.style.animation = '';
        }, 800);
        
        // Atualizar informações detalhadas da barra de progresso
        this.updateProgressDetails();
    }
    
    updateProgressDetails() {
        // Criar ou atualizar container de detalhes do progresso
        let progressDetails = document.querySelector('.progress-details');
        if (!progressDetails) {
            progressDetails = document.createElement('div');
            progressDetails.className = 'progress-details';
            
            const progressContainer = document.querySelector('.progress-container');
            progressContainer.appendChild(progressDetails);
        }
        
        // Calcular estatísticas
        const currentStepInfo = this.steps[this.currentStep];
        const completedSteps = this.currentStep;
        const remainingSteps = this.totalSteps - this.currentStep - 1;
        const progressPercentage = Math.round((this.currentStep / (this.totalSteps - 1)) * 100);
        
        // Validar campos do passo atual
        const currentStepElement = document.querySelector(`[data-step="${this.currentStep}"]`);
        const requiredFields = currentStepElement ? currentStepElement.querySelectorAll('[required]') : [];
        const filledFields = Array.from(requiredFields).filter(field => {
            if (field.type === 'checkbox' || field.type === 'radio') {
                return field.checked;
            }
            return field.value.trim() !== '';
        });
        
        const fieldCompletionPercentage = requiredFields.length > 0 ? 
            Math.round((filledFields.length / requiredFields.length) * 100) : 100;
        
        // Criar HTML dos detalhes
        progressDetails.innerHTML = `
            <div class="progress-info">
                <div class="progress-main-info">
                    <div class="current-step-info">
                        <span class="step-number">${this.currentStep + 1}</span>
                        <span class="step-title">${currentStepInfo.title}</span>
                        <span class="step-percentage">${progressPercentage}%</span>
                    </div>
                    <div class="step-description">
                        ${currentStepInfo.description}
                    </div>
                </div>
                
                <div class="progress-stats">
                    <div class="stat-item">
                        <span class="stat-icon">✅</span>
                        <span class="stat-label">Concluídos</span>
                        <span class="stat-value">${completedSteps}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-icon">📝</span>
                        <span class="stat-label">Atual</span>
                        <span class="stat-value">1</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-icon">⏳</span>
                        <span class="stat-label">Restantes</span>
                        <span class="stat-value">${remainingSteps}</span>
                    </div>
                </div>
                
                <div class="field-completion">
                    <div class="field-completion-header">
                        <span class="field-completion-label">Campos obrigatórios</span>
                        <span class="field-completion-percentage">${filledFields.length}/${requiredFields.length} (${fieldCompletionPercentage}%)</span>
                    </div>
                    <div class="field-completion-bar">
                        <div class="field-completion-fill" style="width: ${fieldCompletionPercentage}%"></div>
                    </div>
                </div>
                
                ${this.getStepValidationStatus()}
            </div>
        `;
        
        // Adicionar animação de entrada
        progressDetails.style.opacity = '0';
        progressDetails.style.transform = 'translateY(-10px)';
        
        setTimeout(() => {
            progressDetails.style.transition = 'all 0.3s ease';
            progressDetails.style.opacity = '1';
            progressDetails.style.transform = 'translateY(0)';
        }, 100);
    }
    
    getStepValidationStatus() {
        const currentStepElement = document.querySelector(`[data-step="${this.currentStep}"]`);
        if (!currentStepElement) return '';
        
        const requiredFields = currentStepElement.querySelectorAll('[required]');
        const errors = [];
        
        requiredFields.forEach(field => {
            const isEmpty = field.type === 'checkbox' || field.type === 'radio' ? 
                !field.checked : field.value.trim() === '';
            
            if (isEmpty) {
                const label = this.getFieldLabel(field);
                errors.push(label || field.name || 'Campo obrigatório');
            }
        });
        
        if (errors.length === 0) {
            return `
                <div class="validation-status success">
                    <span class="validation-icon">✅</span>
                    <span class="validation-message">Todos os campos obrigatórios preenchidos</span>
                </div>
            `;
        } else {
            return `
                <div class="validation-status warning">
                    <span class="validation-icon">⚠️</span>
                    <span class="validation-message">Campos pendentes: ${errors.slice(0, 2).join(', ')}${errors.length > 2 ? '...' : ''}</span>
                </div>
            `;
        }
    }
    
    getFieldLabel(field) {
        // Tentar encontrar label associado
        if (field.id) {
            const label = document.querySelector(`label[for="${field.id}"]`);
            if (label) return label.textContent.replace('*', '').trim();
        }
        
        // Tentar encontrar label pai
        const parentLabel = field.closest('label');
        if (parentLabel) return parentLabel.textContent.replace('*', '').trim();
        
        // Usar placeholder ou name
        return field.placeholder || field.name || 'Campo';
    }
    
    addPageTransitionEffect() {
        // Add subtle page transition effect
        const container = document.querySelector('.multi-step-container');
        if (container) {
            container.style.transform = 'scale(0.98)';
            container.style.transition = 'transform 0.2s ease-out';
            
            setTimeout(() => {
                container.style.transform = 'scale(1)';
                setTimeout(() => {
                    container.style.transition = '';
                }, 200);
            }, 100);
        }
    }
    
    updateStepIndicators() {
        const indicators = document.querySelectorAll('.step-indicator');
        const labels = document.querySelectorAll('.step-label');
        
        indicators.forEach((indicator, index) => {
            indicator.classList.remove('active', 'completed');
            labels[index].classList.remove('active', 'completed');
            
            if (index < this.currentStep) {
                indicator.classList.add('completed');
                labels[index].classList.add('completed');
                indicator.textContent = '';
            } else if (index === this.currentStep) {
                indicator.classList.add('active');
                labels[index].classList.add('active');
                indicator.textContent = index + 1;
            } else {
                indicator.textContent = index + 1;
            }
        });
    }
    
    validateCurrentStep() {
        const currentStepElement = document.querySelector(`[data-step="${this.currentStep}"]`);
        const requiredFields = currentStepElement.querySelectorAll('[required]');
        let isValid = true;
        
        requiredFields.forEach(field => {
            if (!field.value.trim()) {
                this.showFieldError(field, 'Este campo é obrigatório');
                isValid = false;
            } else {
                this.clearFieldError(field);
                
                // Additional validations
                if (field.type === 'email' && !this.isValidEmail(field.value)) {
                    this.showFieldError(field, 'Digite um e-mail válido');
                    isValid = false;
                }
                
                if (field.name === 'confirmaSenha') {
                    const senhaField = document.getElementById('senha');
                    if (senhaField && field.value !== senhaField.value) {
                        this.showFieldError(field, 'As senhas não coincidem');
                        isValid = false;
                    }
                }
            }
        });
        
        // Check terms acceptance on last step
        if (this.currentStep === this.totalSteps - 1) {
            const termsCheckbox = document.getElementById('termosUso');
            if (termsCheckbox && !termsCheckbox.checked) {
                this.showFieldError(termsCheckbox, 'Você deve aceitar os termos de uso');
                isValid = false;
            }
        }
        
        return isValid;
    }
    
    showFieldError(field, message) {
        this.clearFieldError(field);
        
        field.style.borderColor = '#e74c3c';
        field.style.background = '#fdf2f2';
        
        const errorDiv = document.createElement('div');
        errorDiv.className = 'field-error';
        errorDiv.style.cssText = `
            color: #e74c3c;
            font-size: 0.85rem;
            margin-top: 0.25rem;
            animation: fadeIn 0.3s ease;
        `;
        errorDiv.textContent = message;
        
        field.parentNode.appendChild(errorDiv);
        
        // Add shake animation
        field.style.animation = 'shake 0.5s ease-in-out';
        setTimeout(() => {
            field.style.animation = '';
        }, 500);
    }
    
    clearFieldError(field) {
        field.style.borderColor = '';
        field.style.background = '';
        
        const existingError = field.parentNode.querySelector('.field-error');
        if (existingError) {
            existingError.remove();
        }
    }
    
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    
    scrollToTop() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    }
    
    showLoading() {
        const loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'loading-overlay active';
        
        const spinner = this.createSafeElement('div', '', 'loading-spinner');
        loadingOverlay.appendChild(spinner);
        
        document.body.appendChild(loadingOverlay);
        return loadingOverlay;
    }
    
    hideLoading(loadingOverlay) {
        if (loadingOverlay) {
            loadingOverlay.classList.remove('active');
            setTimeout(() => {
                loadingOverlay.remove();
            }, 300);
        }
    }
    
    async submitForm() {
        if (!this.validateCurrentStep()) {
            return;
        }
        
        const loadingOverlay = this.showLoading();
        
        try {
            // Get form data - mantém FormData para suportar upload de arquivos
            const formData = new FormData(this.form);
            
            // Submit to server - sem Content-Type para permitir multipart/form-data
            const response = await fetch('/cadastrar', {
                method: 'POST',
                body: formData // Envia FormData diretamente
            });
            
            const result = await response.json();
            
            if (!response.ok) {
                throw new Error(result.message || 'Ocorreu um erro.');
            }
            
            // Success animation
            this.showSuccessMessage();
            
            setTimeout(() => {
                window.location.href = '../auth/login.html';
            }, 2000);
            
        } catch (error) {
            this.showErrorMessage(`Erro no cadastro: ${error.message}`);
        } finally {
            this.hideLoading(loadingOverlay);
        }
    }
    
    showSuccessMessage() {
        const message = document.createElement('div');
        message.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 2rem 3rem;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(76, 175, 80, 0.3);
            z-index: 10000;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600;
            animation: successPulse 0.6s ease;
        `;
        message.innerHTML = `
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">✓</div>
            Cadastro realizado com sucesso!<br>
            <small style="opacity: 0.9;">Redirecionando para o login...</small>
        `;
        
        document.body.appendChild(message);
        
        setTimeout(() => {
            message.remove();
        }, 2000);
    }
    
    showErrorMessage(text) {
        const message = document.createElement('div');
        message.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #e74c3c;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(231, 76, 60, 0.3);
            z-index: 10000;
            font-weight: 500;
            animation: slideInRight 0.4s ease;
        `;
        message.textContent = text;
        
        document.body.appendChild(message);
        
        setTimeout(() => {
            message.style.animation = 'slideOutRight 0.4s ease';
            setTimeout(() => {
                message.remove();
            }, 400);
        }, 4000);
    }
}

// Add CSS animations
const style = document.createElement('style');
style.textContent = `
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
    }
    
    @keyframes successPulse {
        0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
        50% { transform: translate(-50%, -50%) scale(1.05); }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    
    @keyframes slideInRight {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slideOutRight {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
`;
document.head.appendChild(style);

/* === mascaras.js === */
/**
 * Arquivo de máscaras para os formulários
 * Implementa máscaras para campos como CPF, CNPJ, telefone, CEP, etc.
 */

// Função para aplicar máscara genérica
function aplicarMascara(input, mascara) {
    if (!input) {
        return;
    }
    
    // Função para aplicar a máscara
    function formatarValor(valor) {
        // Remove todos os caracteres não numéricos
        let apenasNumeros = valor.replace(/\D/g, '');
        let valorMascarado = '';
        let indice = 0;
        
        // Aplica a máscara
        for (let i = 0; i < mascara.length && indice < apenasNumeros.length; i++) {
            if (mascara[i] === '#') {
                valorMascarado += apenasNumeros[indice++];
            } else {
                valorMascarado += mascara[i];
            }
        }
        
        return valorMascarado;
    }
    
    // Evento de input
    input.addEventListener('input', function(e) {
        const valorAtual = e.target.value;
        const valorFormatado = formatarValor(valorAtual);
        
        if (valorAtual !== valorFormatado) {
            e.target.value = valorFormatado;
        }
    });
    
    // Evento de paste
    input.addEventListener('paste', function(e) {
        setTimeout(() => {
            const valorAtual = e.target.value;
            const valorFormatado = formatarValor(valorAtual);
            e.target.value = valorFormatado;
        }, 10);
    });
    
    return input;
}

// Função para limitar o número de caracteres
function limitarCaracteres(input, maxLength) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        const valorAtual = e.target.value;
        if (valorAtual.length > maxLength) {
            const novoValor = valorAtual.slice(0, maxLength);
            if (e.target.value !== novoValor) {
                e.target.value = novoValor;
            }
        }
    });
}

// Função para aplicar máscara de telefone
function mascaraTelefone(input) {
    if (!input) return;
    aplicarMascara(input, '(##) #####-####');
}

// Função para aplicar máscara de CEP
function mascaraCEP(input) {
    if (!input) return;
    aplicarMascara(input, '#####-###');
}

// Função para aplicar máscara de CPF
function mascaraCPF(input) {
    if (!input) return;
    aplicarMascara(input, '###.###.###-##');
}

// Função para aplicar máscara de CNPJ
function mascaraCNPJ(input) {
    if (!input) return;
    aplicarMascara(input, '##.###.###/####-##');
}

// Máscara para nomes (apenas letras, espaços e acentos)
function mascaraNome(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        let valor = e.target.value;
        
        // Remove números e caracteres especiais, mantém apenas letras, espaços e acentos
        valor = valor.replace(/[^a-zA-ZÀ-ÿ\s]/g, '');
        
        // Remove espaços múltiplos
        valor = valor.replace(/\s+/g, ' ');
        
        // Capitaliza primeira letra de cada palavra
        valor = valor.replace(/\b\w/g, l => l.toUpperCase());
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
}

// Máscara para campos de endereço (rua, bairro, cidade) com formatação inteligente
function mascaraEndereco(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        let valor = e.target.value;
        
        // Remove caracteres especiais indesejados, mantém letras, números, espaços, acentos e alguns símbolos comuns em endereços
        valor = valor.replace(/[^a-zA-ZÀ-ÿ0-9\s\-\.\,\/]/g, '');
        
        // Remove espaços múltiplos
        valor = valor.replace(/\s+/g, ' ');
        
        // Aplica formatação de nome próprio
        valor = formatarNomeProprio(valor);
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
}

// Máscara para números (apenas dígitos)
function mascaraNumero(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        let valor = e.target.value.replace(/\D/g, '');
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
}

// Máscara para cor do veículo (apenas letras e espaços)
function mascaraCor(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        let valor = e.target.value;
        
        // Remove números e caracteres especiais, mantém apenas letras, espaços e acentos
        valor = valor.replace(/[^a-zA-ZÀ-ÿ\s]/g, '');
        
        // Remove espaços múltiplos
        valor = valor.replace(/\s+/g, ' ');
        
        // Capitaliza primeira letra de cada palavra
        valor = valor.replace(/\b\w/g, l => l.toUpperCase());
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
}

// Função para aplicar máscara de placa de veículo (formato novo Mercosul)
function mascaraPlaca(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        const valorAtual = e.target.value;
        let valor = valorAtual.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
        
        if (valor.length > 0) {
            // Formato Mercosul: ABC1D23 ou ABC1234
            if (valor.length <= 3) {
                // Primeiros 3 caracteres são letras
                valor = valor.replace(/[^A-Z]/g, '');
            } else if (valor.length === 4) {
                // Quarto caractere é número
                valor = valor.slice(0, 3) + valor.slice(3).replace(/[^0-9]/g, '');
            } else if (valor.length === 5) {
                // Quinto caractere pode ser letra (Mercosul) ou número (tradicional)
                valor = valor.slice(0, 4) + valor.slice(4);
            } else {
                // Últimos caracteres são números
                valor = valor.slice(0, 5) + valor.slice(5).replace(/[^0-9]/g, '');
            }
        }
        
        // Limitar ao tamanho máximo
        if (valor.length > 7) {
            valor = valor.slice(0, 7);
        }
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
}

// Função para aplicar máscara de RENAVAM (11 dígitos)
function mascaraRENAVAM(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        const valorAtual = e.target.value;
        let valor = valorAtual.replace(/\D/g, '');
        
        // Limitar a 11 dígitos
        if (valor.length > 11) {
            valor = valor.slice(0, 11);
        }
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
}

// Função para aplicar máscara de CNH (11 dígitos)
function mascaraCNH(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        const valorAtual = e.target.value;
        let valor = valorAtual.replace(/\D/g, '');
        
        // Limitar a 11 dígitos
        if (valor.length > 11) {
            valor = valor.slice(0, 11);
        }
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
}

// Função para aplicar máscara de número de apólice
function mascaraApolice(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        const valorAtual = e.target.value;
        let valor = valorAtual.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
        
        // Limitar a 20 caracteres
        if (valor.length > 20) {
            valor = valor.slice(0, 20);
        }
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
}

// Função para aplicar máscara de email
function mascaraEmail(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        let valor = e.target.value;
        
        // Remove caracteres inválidos para email (mantém apenas letras, números, @, ., -, _)
        valor = valor.replace(/[^a-zA-Z0-9@._-]/g, '');
        
        // Converte para minúsculas
        valor = valor.toLowerCase();
        
        // Evita múltiplos @ consecutivos
        valor = valor.replace(/@+/g, '@');
        
        // Evita múltiplos pontos consecutivos
        valor = valor.replace(/\.+/g, '.');
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
        
        // Validação em tempo real
        validarEmail(e.target, valor);
    });
    
    // Validação no evento blur
    input.addEventListener('blur', function(e) {
        validarEmail(e.target, e.target.value);
    });
}

// Função para validar email em tempo real
function validarEmail(input, valor) {
    // Remove avisos anteriores
    if (input.nextElementSibling && input.nextElementSibling.classList.contains('email-aviso')) {
        input.nextElementSibling.remove();
    }
    
    if (valor.length === 0) return; // Não validar campo vazio
    
    let mensagemErro = '';
    
    // Regex básico para email
    const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    
    // Verificações específicas
    if (!valor.includes('@')) {
        mensagemErro = 'E-mail deve conter @';
    } else if (valor.split('@').length > 2) {
        mensagemErro = 'E-mail deve conter apenas um @';
    } else if (valor.startsWith('@') || valor.endsWith('@')) {
        mensagemErro = 'E-mail não pode começar ou terminar com @';
    } else if (valor.includes('..')) {
        mensagemErro = 'E-mail não pode conter pontos consecutivos';
    } else if (!emailRegex.test(valor)) {
        const partes = valor.split('@');
        if (partes.length === 2) {
            if (partes[0].length === 0) {
                mensagemErro = 'E-mail deve ter texto antes do @';
            } else if (partes[1].length === 0) {
                mensagemErro = 'E-mail deve ter domínio após o @';
            } else if (!partes[1].includes('.')) {
                mensagemErro = 'Domínio deve conter pelo menos um ponto';
            } else if (partes[1].endsWith('.')) {
                mensagemErro = 'Domínio não pode terminar com ponto';
            } else if (partes[1].split('.').some(parte => parte.length < 2)) {
                mensagemErro = 'Extensão do domínio deve ter pelo menos 2 caracteres';
            }
        }
    }
    
    // Mostrar mensagem de erro se houver
    if (mensagemErro) {
        const avisoEmail = document.createElement('small');
        avisoEmail.className = 'email-aviso';
        avisoEmail.style.color = '#e74c3c';
        avisoEmail.style.fontSize = '12px';
        avisoEmail.style.marginTop = '5px';
        avisoEmail.style.display = 'block';
        avisoEmail.textContent = mensagemErro;
        input.parentNode.insertBefore(avisoEmail, input.nextSibling);
    }
}

// Função para mostrar feedback visual quando data futura é bloqueada
function mostrarFeedbackDataFutura(input, tipoDataFutura) {
    // Remove feedback anterior se existir
    if (input.nextElementSibling && input.nextElementSibling.classList.contains('data-futura-feedback')) {
        input.nextElementSibling.remove();
    }
    
    // Criar container de feedback
    const feedbackContainer = document.createElement('div');
    feedbackContainer.className = 'data-futura-feedback';
    feedbackContainer.style.cssText = `
        position: relative;
        margin-top: 8px;
        padding: 12px 16px;
        background: linear-gradient(135deg, #ff6b6b, #ee5a52);
        color: white;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
        animation: slideInFeedback 0.3s ease-out;
        border-left: 4px solid #ff4757;
        display: flex;
        align-items: center;
        gap: 10px;
    `;
    
    // Ícone de aviso
    const icone = document.createElement('span');
    icone.innerHTML = '⚠️';
    icone.style.fontSize = '16px';
    
    // Mensagem personalizada baseada no tipo
    const mensagem = document.createElement('span');
    let textoMensagem = '';
    
    switch(tipoDataFutura) {
        case 'ano':
            textoMensagem = 'Ano futuro detectado! Ajustado para o ano atual.';
            break;
        case 'mês':
            textoMensagem = 'Mês futuro detectado! Ajustado para o mês atual.';
            break;
        case 'dia':
            textoMensagem = 'Data futura detectada! Ajustado para hoje.';
            break;
        default:
            textoMensagem = 'Data futura não permitida! Valor ajustado automaticamente.';
    }
    
    mensagem.textContent = textoMensagem;
    
    // Botão de fechar
    const botaoFechar = document.createElement('button');
    botaoFechar.innerHTML = '×';
    botaoFechar.style.cssText = `
        background: none;
        border: none;
        color: white;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        padding: 0;
        margin-left: auto;
        opacity: 0.8;
        transition: opacity 0.2s;
    `;
    
    botaoFechar.onmouseover = () => botaoFechar.style.opacity = '1';
    botaoFechar.onmouseout = () => botaoFechar.style.opacity = '0.8';
    botaoFechar.onclick = () => feedbackContainer.remove();
    
    // Montar o feedback
    feedbackContainer.appendChild(icone);
    feedbackContainer.appendChild(mensagem);
    feedbackContainer.appendChild(botaoFechar);
    
    // Inserir após o campo
    input.parentNode.insertBefore(feedbackContainer, input.nextSibling);
    
    // Adicionar animação de entrada
    feedbackContainer.style.transform = 'translateY(-10px)';
    feedbackContainer.style.opacity = '0';
    
    setTimeout(() => {
        feedbackContainer.style.transition = 'all 0.3s ease-out';
        feedbackContainer.style.transform = 'translateY(0)';
        feedbackContainer.style.opacity = '1';
    }, 10);
    
    // Remover automaticamente após 4 segundos
    setTimeout(() => {
        if (feedbackContainer.parentNode) {
            feedbackContainer.style.transition = 'all 0.3s ease-in';
            feedbackContainer.style.transform = 'translateY(-10px)';
            feedbackContainer.style.opacity = '0';
            setTimeout(() => {
                if (feedbackContainer.parentNode) {
                    feedbackContainer.remove();
                }
            }, 300);
        }
    }, 4000);
    
    // Adicionar efeito de shake no campo
    input.style.animation = 'shakeField 0.5s ease-in-out';
    setTimeout(() => {
        input.style.animation = '';
    }, 500);
}

// Função para adicionar tooltips informativos aos campos
function adicionarTooltipInformativo(input, tipo) {
    // Remove tooltip anterior se existir
    const tooltipExistente = input.parentNode.querySelector('.tooltip-info');
    if (tooltipExistente) {
        tooltipExistente.remove();
    }
    
    // Criar ícone de informação
    const iconeInfo = document.createElement('span');
    iconeInfo.className = 'tooltip-info';
    iconeInfo.innerHTML = 'ℹ️';
    iconeInfo.style.cssText = `
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        cursor: help;
        font-size: 16px;
        z-index: 10;
        opacity: 0.7;
        transition: opacity 0.2s;
    `;
    
    // Criar tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip-content';
    tooltip.style.cssText = `
        position: absolute;
        bottom: 100%;
        right: 0;
        margin-bottom: 8px;
        padding: 12px 16px;
        background: #2c3e50;
        color: white;
        border-radius: 8px;
        font-size: 13px;
        line-height: 1.4;
        white-space: nowrap;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 1000;
        max-width: 300px;
        white-space: normal;
    `;
    
    // Seta do tooltip
    const seta = document.createElement('div');
    seta.style.cssText = `
        position: absolute;
        top: 100%;
        right: 20px;
        width: 0;
        height: 0;
        border-left: 6px solid transparent;
        border-right: 6px solid transparent;
        border-top: 6px solid #2c3e50;
    `;
    
    // Definir conteúdo baseado no tipo
    let conteudoTooltip = '';
    
    switch(tipo) {
        case 'dataNascimento':
            conteudoTooltip = `
                <strong>📅 Data de Nascimento</strong><br>
                • Não pode ser data futura<br>
                • Motorista deve ter pelo menos 18 anos<br>
                • Formato: DD/MM/AAAA<br>
                • Valores são ajustados automaticamente
            `;
            break;
        case 'validadeCNH':
            conteudoTooltip = `
                <strong>🪪 Validade da CNH</strong><br>
                • CNH não pode estar vencida<br>
                • Data deve ser futura ou atual<br>
                • Formato: DD/MM/AAAA<br>
                • Ajustado automaticamente se vencida
            `;
            break;
        case 'validadeSeguro':
            conteudoTooltip = `
                <strong>🛡️ Validade do Seguro</strong><br>
                • Seguro não pode estar vencido<br>
                • Data deve ser futura ou atual<br>
                • Formato: DD/MM/AAAA<br>
                • Ajustado automaticamente se vencido
            `;
            break;
        case 'email':
            conteudoTooltip = `
                <strong>📧 E-mail</strong><br>
                • Deve conter @ e domínio válido<br>
                • Exemplo: usuario@dominio.com<br>
                • Validação em tempo real<br>
                • Caracteres especiais são removidos
            `;
            break;
        case 'telefone':
            conteudoTooltip = `
                <strong>📞 Telefone</strong><br>
                • Formato: (XX) XXXXX-XXXX<br>
                • Apenas números são aceitos<br>
                • Máscara aplicada automaticamente
            `;
            break;
        case 'cpf':
            conteudoTooltip = `
                <strong>🆔 CPF</strong><br>
                • Formato: XXX.XXX.XXX-XX<br>
                • Apenas números são aceitos<br>
                • Máscara aplicada automaticamente
            `;
            break;
        case 'cep':
            conteudoTooltip = `
                <strong>📍 CEP</strong><br>
                • Formato: XXXXX-XXX<br>
                • Apenas números são aceitos<br>
                • Máscara aplicada automaticamente
            `;
            break;
        default:
            conteudoTooltip = `
                <strong>ℹ️ Campo com validação</strong><br>
                • Este campo possui validações especiais<br>
                • Siga o formato indicado<br>
                • Valores são ajustados automaticamente
            `;
    }
    
    tooltip.innerHTML = conteudoTooltip + seta.outerHTML;
    
    // Posicionar o container do input como relativo
    if (input.parentNode.style.position !== 'relative') {
        input.parentNode.style.position = 'relative';
    }
    
    // Eventos de hover
    iconeInfo.addEventListener('mouseenter', () => {
        iconeInfo.style.opacity = '1';
        tooltip.style.opacity = '1';
        tooltip.style.visibility = 'visible';
        tooltip.style.transform = 'translateY(-5px)';
    });
    
    iconeInfo.addEventListener('mouseleave', () => {
        iconeInfo.style.opacity = '0.7';
        tooltip.style.opacity = '0';
        tooltip.style.visibility = 'hidden';
        tooltip.style.transform = 'translateY(0)';
    });
    
    // Adicionar elementos
    iconeInfo.appendChild(tooltip);
    input.parentNode.appendChild(iconeInfo);
}

// Função para adicionar indicadores visuais de campos obrigatórios vs opcionais
function adicionarIndicadoresCampos() {
    // Selecionar todos os inputs, selects e textareas
    const todosOsCampos = document.querySelectorAll('input, select, textarea');
    
    todosOsCampos.forEach(campo => {
        // Pular campos que não são visíveis ou são do tipo hidden/submit/button
        if (campo.type === 'hidden' || campo.type === 'submit' || campo.type === 'button' || 
            campo.style.display === 'none' || !campo.offsetParent) {
            return;
        }
        
        // Encontrar o label associado
        let label = null;
        
        // Tentar encontrar label por 'for' attribute
        if (campo.id) {
            label = document.querySelector(`label[for="${campo.id}"]`);
        }
        
        // Se não encontrou, tentar encontrar label pai
        if (!label) {
            label = campo.closest('label');
        }
        
        // Se ainda não encontrou, tentar encontrar label irmão anterior
        if (!label) {
            let elemento = campo.previousElementSibling;
            while (elemento) {
                if (elemento.tagName === 'LABEL') {
                    label = elemento;
                    break;
                }
                elemento = elemento.previousElementSibling;
            }
        }
        
        // Se ainda não encontrou, criar um container para o indicador
        if (!label) {
            // Verificar se já existe um indicador
            const indicadorExistente = campo.parentNode.querySelector('.campo-indicador');
            if (indicadorExistente) return;
            
            // Criar container para o indicador
            const container = document.createElement('div');
            container.className = 'campo-indicador';
            container.style.cssText = `
                position: relative;
                display: inline-block;
                width: 100%;
            `;
            
            // Mover o campo para dentro do container
            campo.parentNode.insertBefore(container, campo);
            container.appendChild(campo);
            
            // Adicionar indicador no container
            adicionarIndicadorAoCampo(campo, container, campo.hasAttribute('required'));
        } else {
            // Adicionar indicador ao label existente
            adicionarIndicadorAoLabel(label, campo.hasAttribute('required'));
        }
        
        // Adicionar estilos ao campo baseado no status
        if (campo.hasAttribute('required')) {
            campo.style.borderLeft = '3px solid #e74c3c';
            campo.classList.add('campo-obrigatorio');
        } else {
            campo.style.borderLeft = '3px solid #95a5a6';
            campo.classList.add('campo-opcional');
        }
    });
}

// Função para adicionar indicador ao label
function adicionarIndicadorAoLabel(label, isRequired) {
    // Verificar se já existe indicador
    const indicadorExistente = label.querySelector('.indicador-campo');
    if (indicadorExistente) return;
    
    const indicador = document.createElement('span');
    indicador.className = 'indicador-campo';
    
    if (isRequired) {
        indicador.innerHTML = ' <span style="color: #e74c3c; font-weight: bold;">*</span>';
        indicador.title = 'Campo obrigatório';
    } else {
        indicador.innerHTML = ' <span style="color: #95a5a6; font-size: 12px;">(opcional)</span>';
        indicador.title = 'Campo opcional';
    }
    
    label.appendChild(indicador);
}

// Função para adicionar indicador ao campo (quando não há label)
function adicionarIndicadorAoCampo(campo, container, isRequired) {
    // Verificar se já existe indicador
    const indicadorExistente = container.querySelector('.indicador-campo-direto');
    if (indicadorExistente) return;
    
    const indicador = document.createElement('span');
    indicador.className = 'indicador-campo-direto';
    indicador.style.cssText = `
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 14px;
        font-weight: bold;
        z-index: 5;
        pointer-events: none;
    `;
    
    if (isRequired) {
        indicador.innerHTML = '*';
        indicador.style.color = '#e74c3c';
        indicador.title = 'Campo obrigatório';
    } else {
        indicador.innerHTML = '?';
        indicador.style.color = '#95a5a6';
        indicador.title = 'Campo opcional';
    }
    
    container.appendChild(indicador);
}

// Função para aplicar máscara de complemento (endereço)
function mascaraComplemento(input) {
    if (!input) return;
    
    input.addEventListener('input', function(e) {
        let valor = e.target.value;
        
        // Remove caracteres especiais perigosos, mantém letras, números, espaços e alguns símbolos comuns
        valor = valor.replace(/[^a-zA-ZÀ-ÿ0-9\s.,\-\/°ºª]/g, '');
        
        // Remove espaços múltiplos
        valor = valor.replace(/\s+/g, ' ');
        
        // Capitaliza primeira letra de cada palavra
        valor = valor.replace(/\b\w/g, l => l.toUpperCase());
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
}

// Função para verificar se um ano é bissexto
function isAnoBissexto(ano) {
    return (ano % 4 === 0 && ano % 100 !== 0) || (ano % 400 === 0);
}

// Função para obter o número máximo de dias em um mês
function getDiasMaximosMes(mes, ano) {
    const diasPorMes = {
        1: 31,  // Janeiro
        2: isAnoBissexto(ano) ? 29 : 28,  // Fevereiro
        3: 31,  // Março
        4: 30,  // Abril
        5: 31,  // Maio
        6: 30,  // Junho
        7: 31,  // Julho
        8: 31,  // Agosto
        9: 30,  // Setembro
        10: 31, // Outubro
        11: 30, // Novembro
        12: 31  // Dezembro
    };
    return diasPorMes[mes] || 31;
}

// Função para aplicar máscara de data (formato DD/MM/AAAA)
function mascaraData(input) {
    if (!input) return;
    
    // Verificar se é campo de data de nascimento, validade de CNH ou validade de seguro
    const isDataNascimento = input.id === 'dataNascimento';
    const isValidadeCNH = input.id === 'validadeCNH';
    const isValidadeSeguro = input.id === 'validadeSeguro';
    
    input.addEventListener('input', function(e) {
        const valorAtual = e.target.value;
        let valor = valorAtual.replace(/\D/g, '');
        
        // Validar dia (01-31)
        if (valor.length >= 2) {
            let dia = parseInt(valor.substring(0, 2));
            if (dia > 31) {
                dia = 31;
            } else if (dia === 0) {
                dia = 1;
            }
            valor = String(dia).padStart(2, '0') + valor.substring(2);
        }
        
        // Validar mês (01-12)
        if (valor.length >= 4) {
            let mes = parseInt(valor.substring(2, 4));
            if (mes > 12) {
                mes = 12;
            } else if (mes === 0) {
                mes = 1;
            }
            valor = valor.substring(0, 2) + String(mes).padStart(2, '0') + valor.substring(4);
        }
        
        // Validar dia conforme o mês e ano (se ano estiver disponível)
        if (valor.length >= 8) {
            const dia = parseInt(valor.substring(0, 2));
            const mes = parseInt(valor.substring(2, 4));
            const ano = parseInt(valor.substring(4, 8));
            
            if (ano >= 1900 && ano <= 2100) { // Validar ano razoável
                const diasMaximos = getDiasMaximosMes(mes, ano);
                if (dia > diasMaximos) {
                    valor = String(diasMaximos).padStart(2, '0') + valor.substring(2);
                }
            }
        }
        
        if (valor.length > 0) {
            // Formata como DD/MM/AAAA
            if (valor.length <= 2) {
                // Apenas dia
                valor = valor;
            } else if (valor.length <= 4) {
                // Dia e mês
                valor = valor.substring(0, 2) + '/' + valor.substring(2);
            } else {
                // Dia, mês e ano
                valor = valor.substring(0, 2) + '/' + valor.substring(2, 4) + '/' + valor.substring(4);
            }
        }
        
        // Limitar a 10 caracteres (DD/MM/AAAA)
        if (valor.length > 10) {
            valor = valor.slice(0, 10);
        }
        
        // Validar data futura para campo de data de nascimento em tempo real
        if (isDataNascimento) {
            const dataAtual = new Date();
            const anoAtual = dataAtual.getFullYear();
            let dataFuturaDetectada = false;
            let tipoDataFutura = '';
            
            // Validar apenas ano se tiver 4 dígitos (não validar mês nem dia)
            if (valor.length >= 8) {
                const anoDigitado = parseInt(valor.substring(4, 8));
                if (anoDigitado > anoAtual) {
                    // Se o ano for futuro, usar o ano atual
                    valor = valor.substring(0, 4) + anoAtual;
                    dataFuturaDetectada = true;
                    tipoDataFutura = 'ano';
                }
            }
            
            // Mostrar feedback visual se data futura foi detectada
            if (dataFuturaDetectada) {
                mostrarFeedbackDataFutura(e.target, tipoDataFutura);
            }
            
            // Validação final para data completa
            if (valor.length === 10) {
                const partes = valor.split('/');
                if (partes.length === 3) {
                    const dia = parseInt(partes[0]);
                    const mes = parseInt(partes[1]);
                    const ano = parseInt(partes[2]);
                    
                    // Criar objeto de data
                    const dataDigitada = new Date(ano, mes - 1, dia);
                    
                    // Validar apenas se o ano for futuro (permitir qualquer dia/mês)
                    if (ano > dataAtual.getFullYear()) {
                        // Se o ano for futuro, usar o ano atual mantendo dia e mês
                        valor = `${String(dia).padStart(2, '0')}/${String(mes).padStart(2, '0')}/${dataAtual.getFullYear()}`;
                    }
                    
                    // Validação de idade mínima de 18 anos (maioridade penal brasileira)
                    const dataMinima = new Date();
                    dataMinima.setFullYear(dataMinima.getFullYear() - 18);
                    
                    if (dataDigitada > dataMinima) {
                        // Se a pessoa for menor de 18 anos, usar a data mínima (18 anos atrás)
                        const diaMinimo = String(dataMinima.getDate()).padStart(2, '0');
                        const mesMinimo = String(dataMinima.getMonth() + 1).padStart(2, '0');
                        const anoMinimo = dataMinima.getFullYear();
                        valor = `${diaMinimo}/${mesMinimo}/${anoMinimo}`;
                        
                        // Mostrar mensagem de aviso (opcional)
                        if (input.nextElementSibling && input.nextElementSibling.classList.contains('idade-aviso')) {
                            input.nextElementSibling.remove();
                        }
                        const avisoIdade = document.createElement('small');
                        avisoIdade.className = 'idade-aviso';
                        avisoIdade.style.color = '#e74c3c';
                        avisoIdade.style.fontSize = '12px';
                        avisoIdade.style.marginTop = '5px';
                        avisoIdade.style.display = 'block';
                        avisoIdade.textContent = 'Idade mínima: 18 anos (maioridade penal)';
                        input.parentNode.insertBefore(avisoIdade, input.nextSibling);
                        
                        // Remover aviso após 3 segundos
                        setTimeout(() => {
                            if (avisoIdade.parentNode) {
                                avisoIdade.remove();
                            }
                        }, 3000);
                    }
                }
            }
        }
        
        // Validação para CNH vencida (não permitir datas passadas)
        if (isValidadeCNH && valor.length === 10) {
            const partes = valor.split('/');
            if (partes.length === 3) {
                const dia = parseInt(partes[0]);
                const mes = parseInt(partes[1]);
                const ano = parseInt(partes[2]);
                
                // Criar objeto de data
                const dataDigitada = new Date(ano, mes - 1, dia);
                const dataAtual = new Date();
                
                // Se a data digitada for menor que a data atual (CNH vencida)
                if (dataDigitada < dataAtual) {
                    // Usar a data atual como valor mínimo
                    const diaAtual = String(dataAtual.getDate()).padStart(2, '0');
                    const mesAtual = String(dataAtual.getMonth() + 1).padStart(2, '0');
                    const anoAtual = dataAtual.getFullYear();
                    valor = `${diaAtual}/${mesAtual}/${anoAtual}`;
                    
                    // Mostrar mensagem de aviso
                    if (input.nextElementSibling && input.nextElementSibling.classList.contains('cnh-aviso')) {
                        input.nextElementSibling.remove();
                    }
                    const avisoCNH = document.createElement('small');
                    avisoCNH.className = 'cnh-aviso';
                    avisoCNH.style.color = '#e74c3c';
                    avisoCNH.style.fontSize = '12px';
                    avisoCNH.style.marginTop = '5px';
                    avisoCNH.style.display = 'block';
                    avisoCNH.textContent = 'CNH não pode estar vencida';
                    input.parentNode.insertBefore(avisoCNH, input.nextSibling);
                    
                    // Remover aviso após 3 segundos
                    setTimeout(() => {
                        if (avisoCNH.parentNode) {
                            avisoCNH.remove();
                        }
                    }, 3000);
                }
            }
            
            // Validar seguro vencido para campo de validade do seguro
            if (isValidadeSeguro) {
                const dataDigitada = new Date(ano, mes - 1, dia);
                const dataAtual = new Date();
                
                // Se a data digitada for menor que a data atual (seguro vencido)
                if (dataDigitada < dataAtual) {
                    // Usar a data atual como valor mínimo
                    const diaAtual = String(dataAtual.getDate()).padStart(2, '0');
                    const mesAtual = String(dataAtual.getMonth() + 1).padStart(2, '0');
                    const anoAtual = dataAtual.getFullYear();
                    valor = `${diaAtual}/${mesAtual}/${anoAtual}`;
                    
                    // Mostrar mensagem de aviso
                    if (e.target.nextElementSibling && e.target.nextElementSibling.classList.contains('seguro-aviso')) {
                        e.target.nextElementSibling.remove();
                    }
                    const avisoSeguro = document.createElement('small');
                    avisoSeguro.className = 'seguro-aviso';
                    avisoSeguro.style.color = '#e74c3c';
                    avisoSeguro.style.fontSize = '12px';
                    avisoSeguro.style.marginTop = '5px';
                    avisoSeguro.style.display = 'block';
                    avisoSeguro.textContent = 'Seguro não pode estar vencido';
                    e.target.parentNode.insertBefore(avisoSeguro, e.target.nextSibling);
                    
                    // Remover aviso após 3 segundos
                    setTimeout(() => {
                        if (avisoSeguro.parentNode) {
                            avisoSeguro.remove();
                        }
                    }, 3000);
                }
            }
        }
        
        if (e.target.value !== valor) {
            e.target.value = valor;
        }
    });
    
    // Adicionar validação no evento keydown para campos de data de nascimento
    if (isDataNascimento) {
        input.addEventListener('keydown', function(e) {
            // Permitir teclas de controle (backspace, delete, tab, etc.)
            if (e.key === 'Backspace' || e.key === 'Delete' || e.key === 'Tab' || 
                e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'Home' || e.key === 'End') {
                return;
            }
            
            // Verificar se é um número
            if (!/^\d$/.test(e.key)) {
                e.preventDefault();
                return;
            }
            
            const valorAtual = e.target.value.replace(/\D/g, '');
            const posicaoCursor = e.target.selectionStart;
            const novoDigito = e.key;
            
            // Simular o valor após a digitação
            let novoValor = valorAtual.slice(0, posicaoCursor) + novoDigito + valorAtual.slice(posicaoCursor);
            
            const dataAtual = new Date();
            const anoAtual = dataAtual.getFullYear();
            const mesAtual = dataAtual.getMonth() + 1;
            const diaAtual = dataAtual.getDate();
            
            // Validar apenas ano futuro (permitir qualquer dia e mês)
            if (posicaoCursor >= 4 && posicaoCursor <= 7) {
                // Digitando o ano
                if (novoValor.length >= 8) {
                    const anoDigitado = parseInt(novoValor.substring(4, 8));
                    if (anoDigitado > anoAtual) {
                        e.preventDefault();
                        return;
                    }
                }
            }
        });
    }
    
    // Adicionar validação no evento blur para verificar a data completa
    input.addEventListener('blur', function(e) {
        const valor = e.target.value;
        if (valor.length === 10) {
            const partes = valor.split('/');
            if (partes.length === 3) {
                const dia = parseInt(partes[0]);
                const mes = parseInt(partes[1]);
                const ano = parseInt(partes[2]);
                
                // Validar se a data é válida
                const diasMaximos = getDiasMaximosMes(mes, ano);
                if (dia > diasMaximos) {
                    const diaCorrigido = String(diasMaximos).padStart(2, '0');
                    e.target.value = `${diaCorrigido}/${String(mes).padStart(2, '0')}/${ano}`;
                }
                
                // Validar data futura para campo de data de nascimento
                if (isDataNascimento) {
                    const dataDigitada = new Date(ano, mes - 1, dia);
                    const dataAtual = new Date();
                    
                    // Validar apenas se o ano for futuro (permitir qualquer dia/mês)
                    if (ano > dataAtual.getFullYear()) {
                        // Se o ano for futuro, usar o ano atual mantendo dia e mês
                        e.target.value = `${String(dia).padStart(2, '0')}/${String(mes).padStart(2, '0')}/${dataAtual.getFullYear()}`;
                    }
                    
                    // Validação de idade mínima de 18 anos (maioridade penal brasileira)
                    const dataMinima = new Date();
                    dataMinima.setFullYear(dataMinima.getFullYear() - 18);
                    
                    if (dataDigitada > dataMinima) {
                        // Se a pessoa for menor de 18 anos, usar a data mínima (18 anos atrás)
                        const diaMinimo = String(dataMinima.getDate()).padStart(2, '0');
                        const mesMinimo = String(dataMinima.getMonth() + 1).padStart(2, '0');
                        const anoMinimo = dataMinima.getFullYear();
                        e.target.value = `${diaMinimo}/${mesMinimo}/${anoMinimo}`;
                        
                        // Mostrar mensagem de aviso
                        if (e.target.nextElementSibling && e.target.nextElementSibling.classList.contains('idade-aviso')) {
                            e.target.nextElementSibling.remove();
                        }
                        const avisoIdade = document.createElement('small');
                        avisoIdade.className = 'idade-aviso';
                        avisoIdade.style.color = '#e74c3c';
                        avisoIdade.style.fontSize = '12px';
                        avisoIdade.style.marginTop = '5px';
                        avisoIdade.style.display = 'block';
                        avisoIdade.textContent = 'Idade mínima: 18 anos (maioridade penal)';
                        e.target.parentNode.insertBefore(avisoIdade, e.target.nextSibling);
                        
                        // Remover aviso após 3 segundos
                        setTimeout(() => {
                            if (avisoIdade.parentNode) {
                                avisoIdade.remove();
                            }
                        }, 3000);
                    }
                }
                
                // Validar CNH vencida para campo de validade da CNH
                if (isValidadeCNH) {
                    const dataDigitada = new Date(ano, mes - 1, dia);
                    const dataAtual = new Date();
                    
                    // Se a data digitada for menor que a data atual (CNH vencida)
                    if (dataDigitada < dataAtual) {
                        // Usar a data atual como valor mínimo
                        const diaAtual = String(dataAtual.getDate()).padStart(2, '0');
                        const mesAtual = String(dataAtual.getMonth() + 1).padStart(2, '0');
                        const anoAtual = dataAtual.getFullYear();
                        e.target.value = `${diaAtual}/${mesAtual}/${anoAtual}`;
                        
                        // Mostrar mensagem de aviso
                        if (e.target.nextElementSibling && e.target.nextElementSibling.classList.contains('cnh-aviso')) {
                            e.target.nextElementSibling.remove();
                        }
                        const avisoCNH = document.createElement('small');
                        avisoCNH.className = 'cnh-aviso';
                        avisoCNH.style.color = '#e74c3c';
                        avisoCNH.style.fontSize = '12px';
                        avisoCNH.style.marginTop = '5px';
                        avisoCNH.style.display = 'block';
                        avisoCNH.textContent = 'CNH não pode estar vencida';
                        e.target.parentNode.insertBefore(avisoCNH, e.target.nextSibling);
                        
                        // Remover aviso após 3 segundos
                        setTimeout(() => {
                            if (avisoCNH.parentNode) {
                                avisoCNH.remove();
                            }
                        }, 3000);
                    }
                }
                
                // Validar seguro vencido para campo de validade do seguro
                if (isValidadeSeguro) {
                    const dataDigitada = new Date(ano, mes - 1, dia);
                    const dataAtual = new Date();
                    
                    // Se a data digitada for menor que a data atual (seguro vencido)
                    if (dataDigitada < dataAtual) {
                        // Usar a data atual como valor mínimo
                        const diaAtual = String(dataAtual.getDate()).padStart(2, '0');
                        const mesAtual = String(dataAtual.getMonth() + 1).padStart(2, '0');
                        const anoAtual = dataAtual.getFullYear();
                        e.target.value = `${diaAtual}/${mesAtual}/${anoAtual}`;
                        
                        // Mostrar mensagem de aviso
                        if (e.target.nextElementSibling && e.target.nextElementSibling.classList.contains('seguro-aviso')) {
                            e.target.nextElementSibling.remove();
                        }
                        const avisoSeguro = document.createElement('small');
                        avisoSeguro.className = 'seguro-aviso';
                        avisoSeguro.style.color = '#e74c3c';
                        avisoSeguro.style.fontSize = '12px';
                        avisoSeguro.style.marginTop = '5px';
                        avisoSeguro.style.display = 'block';
                        avisoSeguro.textContent = 'Seguro não pode estar vencido';
                        e.target.parentNode.insertBefore(avisoSeguro, e.target.nextSibling);
                        
                        // Remover aviso após 3 segundos
                        setTimeout(() => {
                            if (avisoSeguro.parentNode) {
                                avisoSeguro.remove();
                            }
                        }, 3000);
                    }
                }
            }
        }
    });
}

/**
 * Validação de CNPJ em tempo real
 * @param {string} cnpj - CNPJ para validar
 * @returns {Object} - {valid: boolean, message: string}
 */
function validarCNPJ(cnpj) {
    // Remove caracteres não numéricos
    cnpj = cnpj.replace(/[^\d]/g, '');
    
    // Verifica se tem 14 dígitos
    if (cnpj.length !== 14) {
        return { valid: false, message: 'CNPJ deve ter 14 dígitos' };
    }
    
    // Verifica se todos os dígitos são iguais
    if (/^(\d)\1{13}$/.test(cnpj)) {
        return { valid: false, message: 'CNPJ inválido - todos os dígitos são iguais' };
    }
    
    // Validação do primeiro dígito verificador
    let soma = 0;
    let peso = 5;
    
    for (let i = 0; i < 12; i++) {
        soma += parseInt(cnpj.charAt(i)) * peso;
        peso = peso === 2 ? 9 : peso - 1;
    }
    
    let resto = soma % 11;
    let digito1 = resto < 2 ? 0 : 11 - resto;
    
    if (parseInt(cnpj.charAt(12)) !== digito1) {
        return { valid: false, message: 'CNPJ inválido - primeiro dígito verificador incorreto' };
    }
    
    // Validação do segundo dígito verificador
    soma = 0;
    peso = 6;
    
    for (let i = 0; i < 13; i++) {
        soma += parseInt(cnpj.charAt(i)) * peso;
        peso = peso === 2 ? 9 : peso - 1;
    }
    
    resto = soma % 11;
    let digito2 = resto < 2 ? 0 : 11 - resto;
    
    if (parseInt(cnpj.charAt(13)) !== digito2) {
        return { valid: false, message: 'CNPJ inválido - segundo dígito verificador incorreto' };
    }
    
    return { valid: true, message: 'CNPJ válido' };
}

/**
 * Validação de placa de veículo (Mercosul e formato antigo)
 * @param {string} placa - Placa para validar
 * @returns {Object} - {valid: boolean, message: string, format: string}
 */
function validarPlaca(placa) {
    // Remove espaços e converte para maiúsculo
    placa = placa.replace(/\s/g, '').toUpperCase();
    
    // Formato antigo: ABC1234
    const formatoAntigo = /^[A-Z]{3}[0-9]{4}$/;
    
    // Formato Mercosul: ABC1D23
    const formatoMercosul = /^[A-Z]{3}[0-9][A-Z][0-9]{2}$/;
    
    if (formatoAntigo.test(placa)) {
        return { 
            valid: true, 
            message: 'Placa válida (formato antigo)', 
            format: 'antigo' 
        };
    }
    
    if (formatoMercosul.test(placa)) {
        return { 
            valid: true, 
            message: 'Placa válida (formato Mercosul)', 
            format: 'mercosul' 
        };
    }
    
    // Verificar se está no formato parcial para dar feedback específico
    if (placa.length < 7) {
        return { 
            valid: false, 
            message: 'Placa incompleta. Formato: ABC1234 (antigo) ou ABC1D23 (Mercosul)', 
            format: 'incompleto' 
        };
    }
    
    if (placa.length > 7) {
        return { 
            valid: false, 
            message: 'Placa muito longa. Máximo 7 caracteres', 
            format: 'invalido' 
        };
    }
    
    return { 
        valid: false, 
        message: 'Formato de placa inválido. Use ABC1234 (antigo) ou ABC1D23 (Mercosul)', 
        format: 'invalido' 
    };
}

/**
 * Aplica máscara de CNPJ e validação em tempo real
 * @param {HTMLElement} elemento - Campo de input
 */
function aplicarMascaraCNPJ(elemento) {
    if (!elemento) return;
    
    // Aplicar máscara
    elemento.addEventListener('input', function(e) {
        let valor = e.target.value.replace(/[^\d]/g, '');
        
        // Aplicar máscara: 00.000.000/0000-00
        if (valor.length <= 14) {
            valor = valor.replace(/^(\d{2})(\d)/, '$1.$2');
            valor = valor.replace(/^(\d{2})\.(\d{3})(\d)/, '$1.$2.$3');
            valor = valor.replace(/\.(\d{3})(\d)/, '.$1/$2');
            valor = valor.replace(/(\d{4})(\d)/, '$1-$2');
        }
        
        e.target.value = valor;
        
        // Validar em tempo real se tiver 14 dígitos
        const apenasNumeros = valor.replace(/[^\d]/g, '');
        if (apenasNumeros.length === 14) {
            const validacao = validarCNPJ(apenasNumeros);
            mostrarFeedbackValidacao(elemento, validacao.valid, validacao.message);
        } else if (apenasNumeros.length > 0) {
            mostrarFeedbackValidacao(elemento, null, 'Digite o CNPJ completo para validar');
        } else {
            removerFeedbackValidacao(elemento);
        }
    });
}

/**
 * Aplica máscara de placa e validação em tempo real
 * @param {HTMLElement} elemento - Campo de input
 */
function aplicarMascaraPlaca(elemento) {
    if (!elemento) return;
    
    elemento.addEventListener('input', function(e) {
        let valor = e.target.value.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
        
        // Limitar a 7 caracteres
        if (valor.length > 7) {
            valor = valor.substring(0, 7);
        }
        
        // Aplicar máscara baseada no formato
        if (valor.length >= 4) {
            // Detectar se é formato Mercosul ou antigo baseado no 5º caractere
            if (valor.length >= 5 && /[A-Z]/.test(valor.charAt(4))) {
                // Formato Mercosul: ABC1D23
                valor = valor.replace(/^([A-Z]{3})([0-9])([A-Z])([0-9]{0,2})/, '$1$2$3$4');
            } else {
                // Formato antigo: ABC1234
                valor = valor.replace(/^([A-Z]{3})([0-9]{0,4})/, '$1$2');
            }
        }
        
        e.target.value = valor;
        
        // Validar em tempo real
        if (valor.length >= 3) {
            const validacao = validarPlaca(valor);
            if (valor.length === 7) {
                mostrarFeedbackValidacao(elemento, validacao.valid, validacao.message);
            } else {
                mostrarFeedbackValidacao(elemento, null, 'Digite a placa completa para validar');
            }
        } else {
            removerFeedbackValidacao(elemento);
        }
    });
}

/**
 * Mostra feedback de validação para um campo
 * @param {HTMLElement} elemento - Campo de input
 * @param {boolean|null} isValid - true=válido, false=inválido, null=neutro
 * @param {string} message - Mensagem de feedback
 */
function mostrarFeedbackValidacao(elemento, isValid, message) {
    // Remove feedback anterior
    removerFeedbackValidacao(elemento);
    
    // Criar container de feedback
    const feedback = document.createElement('div');
    feedback.className = 'validacao-feedback';
    feedback.textContent = message;
    
    // Aplicar estilo baseado na validação
    if (isValid === true) {
        feedback.classList.add('valido');
        elemento.classList.add('campo-valido');
        elemento.classList.remove('campo-invalido');
    } else if (isValid === false) {
        feedback.classList.add('invalido');
        elemento.classList.add('campo-invalido');
        elemento.classList.remove('campo-valido');
    } else {
        feedback.classList.add('neutro');
        elemento.classList.remove('campo-valido', 'campo-invalido');
    }
    
    // Inserir feedback após o elemento
    elemento.parentNode.insertBefore(feedback, elemento.nextSibling);
}

/**
 * Remove feedback de validação de um campo
 * @param {HTMLElement} elemento - Campo de input
 */
function removerFeedbackValidacao(elemento) {
    const feedbackExistente = elemento.parentNode.querySelector('.validacao-feedback');
    if (feedbackExistente) {
        feedbackExistente.remove();
    }
    elemento.classList.remove('campo-valido', 'campo-invalido');
}

// ===== FUNCIONALIDADES AVANÇADAS =====

// Auto-preenchimento de endereço via CEP usando rota do backend
async function buscarEnderecoPorCEP(cep, sufixo = '', tentativa = 1) {
    try {
        // Remove caracteres não numéricos
        const cepLimpo = cep.replace(/\D/g, '');
        
        // Verifica se o CEP tem 8 dígitos
        if (cepLimpo.length !== 8) {
            throw new Error('CEP deve ter 8 dígitos');
        }
        
        // Validação básica de CEP (não pode ser 00000000 ou todos os dígitos iguais)
        if (cepLimpo === '00000000' || 
            cepLimpo === '11111111' || 
            cepLimpo === '22222222' || 
            cepLimpo === '33333333' || 
            cepLimpo === '44444444' || 
            cepLimpo === '55555555' || 
            cepLimpo === '66666666' || 
            cepLimpo === '77777777' || 
            cepLimpo === '88888888' || 
            cepLimpo === '99999999') {
            throw new Error('CEP inválido');
        }
        
        // Mostra feedback de carregamento
        const mensagemCarregamento = tentativa > 1 ? 
            `Buscando CEP... (tentativa ${tentativa})` : 
            'Buscando CEP...';
        mostrarFeedbackCEP(cep, 'loading', mensagemCarregamento, sufixo);
        
        // Faz requisição para a rota do backend com timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 segundos
        
        const response = await fetch(`/api/cep/${cepLimpo}`, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            const errorMessage = errorData.details || errorData.error || `Erro HTTP ${response.status}`;
            
            // Se for erro 404 (CEP não encontrado), não tenta novamente
            if (response.status === 404) {
                throw new Error(errorMessage);
            }
            
            // Para outros erros, permite retry
            if (tentativa < 3) {
                console.warn(`Tentativa ${tentativa} falhou, tentando novamente...`);
                await new Promise(resolve => setTimeout(resolve, 1000 * tentativa)); // Delay progressivo
                return buscarEnderecoPorCEP(cep, sufixo, tentativa + 1);
            }
            
            throw new Error(errorMessage);
        }
        
        const dados = await response.json();
        
        // Validação dos dados essenciais (localidade e UF são obrigatórios)
        if (!dados || !dados.localidade || !dados.uf) {
            throw new Error('CEP não encontrado ou dados incompletos');
        }
        
        // Preenche os campos automaticamente
        preencherCamposEndereco(dados, sufixo);
        
        // Mostra feedback de sucesso
        mostrarFeedbackCEP(cep, 'success', 'CEP encontrado! Endereço preenchido automaticamente.', sufixo);
        
        return dados;
    } catch (error) {
        console.error('Erro ao buscar CEP:', error);
        
        let mensagemErro = 'Erro ao buscar CEP';
        
        if (error.name === 'AbortError') {
            mensagemErro = 'Timeout: Verifique sua conexão e tente novamente';
        } else if (error.message.includes('CEP não encontrado')) {
            mensagemErro = 'CEP não encontrado. Verifique se está correto';
        } else if (error.message.includes('CEP inválido')) {
            mensagemErro = 'CEP inválido. Digite um CEP válido';
        } else if (error.message.includes('8 dígitos')) {
            mensagemErro = 'CEP deve ter 8 dígitos';
        } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
            mensagemErro = 'Erro de conexão. Verifique sua internet';
        } else {
            mensagemErro = `${error.message}`;
        }
        
        mostrarFeedbackCEP(cep, 'error', mensagemErro, sufixo);
        return null;
    }
}


// Função para formatar nomes próprios (capitalizar primeira letra de cada palavra)
function formatarNomeProprio(texto) {
    if (!texto) return '';
    
    return texto
        .toLowerCase()
        .split(' ')
        .map(palavra => {
            // Lista de preposições e artigos que devem ficar em minúsculo
            const preposicoes = ['de', 'da', 'do', 'das', 'dos', 'e', 'em', 'na', 'no', 'nas', 'nos', 'a', 'o', 'as', 'os'];
            
            // Se a palavra está na lista de preposições e não é a primeira palavra
            if (preposicoes.includes(palavra.toLowerCase()) && texto.split(' ').indexOf(palavra) !== 0) {
                return palavra.toLowerCase();
            }
            
            // Capitaliza a primeira letra
            return palavra.charAt(0).toUpperCase() + palavra.slice(1);
        })
        .join(' ');
}

function preencherCamposEndereco(dados, sufixo = '') {
    const campos = {
        rua: formatarNomeProprio(dados.logradouro),
        bairro: formatarNomeProprio(dados.bairro),
        cidade: formatarNomeProprio(dados.localidade),
        estado: dados.uf ? dados.uf.toUpperCase() : ''
    };
    
    Object.entries(campos).forEach(([campo, valor]) => {
        const elemento = document.getElementById(campo + sufixo);
        if (elemento && valor) {
            elemento.value = valor;
            // Dispara evento de input para atualizar validações
            elemento.dispatchEvent(new Event('input', { bubbles: true }));
        }
    });
}

function mostrarFeedbackCEP(cep, tipo, mensagem, sufixo = '') {
    const campoCEP = document.getElementById('cep' + sufixo);
    if (!campoCEP) return;
    
    // Remove feedback anterior
    removerFeedbackValidacao(campoCEP);
    
    // Determina o estado de validação baseado no tipo
    let isValid = null;
    if (tipo === 'success') {
        isValid = true;
    } else if (tipo === 'error') {
        isValid = false;
    } else if (tipo === 'loading') {
        isValid = null; // Estado neutro para loading
    }
    
    // Adiciona novo feedback
    mostrarFeedbackValidacao(campoCEP, isValid, mensagem);
    
    // Adiciona classe especial para loading
    if (tipo === 'loading') {
        const feedback = campoCEP.parentNode.querySelector('.validacao-feedback');
        if (feedback) {
            feedback.classList.add('loading');
        }
    }
}

function aplicarAutoPreenchimentoCEP(campo) {
    let timeoutId;
    let ultimoCepBuscado = '';
    let buscandoCEP = false;
    
    campo.addEventListener('input', function() {
        clearTimeout(timeoutId);
        
        const cep = this.value.replace(/\D/g, '');
        
        // Limpar feedback se CEP incompleto
        if (cep.length < 8) {
            const sufixo = this.id.replace('cep', '');
            const campoCEP = document.getElementById('cep' + sufixo);
            if (campoCEP) {
                removerFeedbackValidacao(campoCEP);
            }
            return;
        }
        
        // Se o CEP tem 8 dígitos e é diferente do último buscado
        if (cep.length === 8 && cep !== ultimoCepBuscado && !buscandoCEP) {
            timeoutId = setTimeout(() => {
                const sufixo = this.id.replace('cep', '');
                ultimoCepBuscado = cep;
                buscandoCEP = true;
                
                buscarEnderecoPorCEP(cep, sufixo).finally(() => {
                    buscandoCEP = false;
                });
            }, 800); // Aguarda 800ms após parar de digitar
        }
    });
    
    // Também permite busca manual ao sair do campo
    campo.addEventListener('blur', function() {
        clearTimeout(timeoutId);
        
        const cep = this.value.replace(/\D/g, '');
        if (cep.length === 8 && cep !== ultimoCepBuscado && !buscandoCEP) {
            const sufixo = this.id.replace('cep', '');
            ultimoCepBuscado = cep;
            buscandoCEP = true;
            
            buscarEnderecoPorCEP(cep, sufixo).finally(() => {
                buscandoCEP = false;
            });
        }
    });
    
    // Adicionar indicador visual quando estiver buscando
    campo.addEventListener('focus', function() {
        const cep = this.value.replace(/\D/g, '');
        if (cep.length === 8 && buscandoCEP) {
            const sufixo = this.id.replace('cep', '');
            mostrarFeedbackCEP(cep, 'loading', 'Buscando CEP...', sufixo);
        }
    });
}

// Validação avançada de telefone
function validarTelefone(telefone) {
    // Remove caracteres não numéricos
    const numeroLimpo = telefone.replace(/\D/g, '');
    
    // Verifica se é um número válido
    if (numeroLimpo.length < 10 || numeroLimpo.length > 11) {
        return {
            valido: false,
            mensagem: 'Telefone deve ter 10 ou 11 dígitos',
            tipo: 'fixo'
        };
    }
    
    // Verifica se é celular (9 dígitos após DDD) ou fixo (8 dígitos após DDD)
    const ddd = numeroLimpo.substring(0, 2);
    const numero = numeroLimpo.substring(2);
    
    // Lista de DDDs válidos no Brasil
    const dddsValidos = [
        '11', '12', '13', '14', '15', '16', '17', '18', '19', // SP
        '21', '22', '24', // RJ
        '27', '28', // ES
        '31', '32', '33', '34', '35', '37', '38', // MG
        '41', '42', '43', '44', '45', '46', // PR
        '47', '48', '49', // SC
        '51', '53', '54', '55', // RS
        '61', // DF
        '62', '64', // GO
        '63', // TO
        '65', '66', // MT
        '67', // MS
        '68', // AC
        '69', // RO
        '71', '73', '74', '75', '77', // BA
        '79', // SE
        '81', '87', // PE
        '82', // AL
        '83', // PB
        '84', // RN
        '85', '88', // CE
        '86', '89', // PI
        '91', '93', '94', // PA
        '92', '97', // AM
        '95', // RR
        '96', // AP
        '98', '99' // MA
    ];
    
    if (!dddsValidos.includes(ddd)) {
        return {
            valido: false,
            mensagem: 'DDD inválido',
            tipo: 'fixo'
        };
    }
    
    // Determina se é celular ou fixo
    const isCelular = numero.length === 9 && numero.startsWith('9');
    const isFixo = numero.length === 8 && !numero.startsWith('9');
    
    if (!isCelular && !isFixo) {
        return {
            valido: false,
            mensagem: isCelular ? 'Número de celular inválido' : 'Número de telefone inválido',
            tipo: numero.length === 9 ? 'celular' : 'fixo'
        };
    }
    
    return {
        valido: true,
        mensagem: `${isCelular ? 'Celular' : 'Telefone fixo'} válido`,
        tipo: isCelular ? 'celular' : 'fixo'
    };
}

// Máscara inteligente de telefone que detecta celular vs fixo
function aplicarMascaraTelefoneInteligente(campo) {
    campo.addEventListener('input', function() {
        let valor = this.value.replace(/\D/g, '');
        
        // Limita a 11 dígitos
        if (valor.length > 11) {
            valor = valor.substring(0, 11);
        }
        
        let valorFormatado = '';
        
        if (valor.length > 0) {
            // Adiciona parênteses no DDD
            if (valor.length <= 2) {
                valorFormatado = `(${valor}`;
            } else if (valor.length <= 6) {
                // Formato: (XX) XXXX
                valorFormatado = `(${valor.substring(0, 2)}) ${valor.substring(2)}`;
            } else if (valor.length <= 10) {
                // Formato: (XX) XXXX-XXXX (telefone fixo)
                valorFormatado = `(${valor.substring(0, 2)}) ${valor.substring(2, 6)}-${valor.substring(6)}`;
            } else {
                // Formato: (XX) 9XXXX-XXXX (celular)
                valorFormatado = `(${valor.substring(0, 2)}) ${valor.substring(2, 7)}-${valor.substring(7)}`;
            }
        }
        
        this.value = valorFormatado;
        
        // Valida o telefone em tempo real
        if (valor.length >= 10) {
            const validacao = validarTelefone(valor);
            mostrarFeedbackValidacao(this, validacao.valido, validacao.mensagem);
        } else {
            removerFeedbackValidacao(this);
        }
    });
}

// Validação avançada de CPF
function validarCPFCompleto(cpf) {
    // Remove caracteres não numéricos
    const cpfLimpo = cpf.replace(/\D/g, '');
    
    // Verifica se tem 11 dígitos
    if (cpfLimpo.length !== 11) {
        return { valido: false, mensagem: 'CPF deve ter 11 dígitos' };
    }
    
    // Verifica se todos os dígitos são iguais
    if (/^(\d)\1{10}$/.test(cpfLimpo)) {
        return { valido: false, mensagem: 'CPF não pode ter todos os dígitos iguais' };
    }
    
    // Calcula o primeiro dígito verificador
    let soma = 0;
    for (let i = 0; i < 9; i++) {
        soma += parseInt(cpfLimpo.charAt(i)) * (10 - i);
    }
    let resto = 11 - (soma % 11);
    let digitoVerificador1 = resto < 2 ? 0 : resto;
    
    if (parseInt(cpfLimpo.charAt(9)) !== digitoVerificador1) {
        return { valido: false, mensagem: 'CPF inválido - primeiro dígito verificador incorreto' };
    }
    
    // Calcula o segundo dígito verificador
    soma = 0;
    for (let i = 0; i < 10; i++) {
        soma += parseInt(cpfLimpo.charAt(i)) * (11 - i);
    }
    resto = 11 - (soma % 11);
    let digitoVerificador2 = resto < 2 ? 0 : resto;
    
    if (parseInt(cpfLimpo.charAt(10)) !== digitoVerificador2) {
        return { valido: false, mensagem: 'CPF inválido - segundo dígito verificador incorreto' };
    }
    
    return { valido: true, mensagem: 'CPF válido' };
}

// Validação avançada de CNH
function validarCNH(cnh) {
    // Remove caracteres não numéricos
    const cnhLimpa = cnh.replace(/\D/g, '');
    
    // Verifica se tem 11 dígitos
    if (cnhLimpa.length !== 11) {
        return { valido: false, mensagem: 'CNH deve ter 11 dígitos' };
    }
    
    // Verifica se todos os dígitos são iguais
    if (/^(\d)\1{10}$/.test(cnhLimpa)) {
        return { valido: false, mensagem: 'CNH não pode ter todos os dígitos iguais' };
    }
    
    // Algoritmo de validação da CNH
    let soma = 0;
    let sequencia = 0;
    
    // Calcula o primeiro dígito verificador
    for (let i = 0; i < 9; i++) {
        soma += parseInt(cnhLimpa.charAt(i)) * (9 - i);
    }
    
    let digitoVerificador1 = soma % 11;
    if (digitoVerificador1 >= 2) {
        digitoVerificador1 = 11 - digitoVerificador1;
    } else {
        digitoVerificador1 = 0;
    }
    
    if (parseInt(cnhLimpa.charAt(9)) !== digitoVerificador1) {
        return { valido: false, mensagem: 'CNH inválida - primeiro dígito verificador incorreto' };
    }
    
    // Calcula o segundo dígito verificador
    soma = 0;
    for (let i = 0; i < 9; i++) {
        soma += parseInt(cnhLimpa.charAt(i)) * (1 + i);
    }
    soma += digitoVerificador1 * 10;
    
    let digitoVerificador2 = soma % 11;
    if (digitoVerificador2 >= 2) {
        digitoVerificador2 = 11 - digitoVerificador2;
    } else {
        digitoVerificador2 = 0;
    }
    
    if (parseInt(cnhLimpa.charAt(10)) !== digitoVerificador2) {
        return { valido: false, mensagem: 'CNH inválida - segundo dígito verificador incorreto' };
    }
    
    return { valido: true, mensagem: 'CNH válida' };
}

// Aplicar máscara e validação de CNH
function aplicarMascaraCNH(campo) {
    campo.addEventListener('input', function() {
        let valor = this.value.replace(/\D/g, '');
        
        // Limita a 11 dígitos
        if (valor.length > 11) {
            valor = valor.substring(0, 11);
        }
        
        // Aplica a máscara: XXXXXXXXXXX
        this.value = valor;
        
        // Valida em tempo real
        if (valor.length === 11) {
            const validacao = validarCNH(valor);
            mostrarFeedbackValidacao(this, validacao.valido, validacao.mensagem);
        } else if (valor.length > 0) {
            mostrarFeedbackValidacao(this, false, `CNH deve ter 11 dígitos (${valor.length}/11)`);
        } else {
            removerFeedbackValidacao(this);
        }
    });
}

// Aplicar validação completa de CPF
function aplicarValidacaoCPFCompleta(campo) {
    campo.addEventListener('input', function() {
        const cpf = this.value.replace(/\D/g, '');
        
        if (cpf.length === 11) {
            const validacao = validarCPFCompleto(cpf);
            mostrarFeedbackValidacao(this, validacao.valido, validacao.mensagem);
        } else if (cpf.length > 0) {
            mostrarFeedbackValidacao(this, false, `CPF deve ter 11 dígitos (${cpf.length}/11)`);
        } else {
            removerFeedbackValidacao(this);
        }
    });
}

// Função principal para inicializar todas as máscaras
function inicializarMascaras() {
    try {
        // Aplicar máscaras para campos de telefone
        const camposTelefone = document.querySelectorAll('#celular, #telefone, #telefoneEmergencia, #telefoneEmpresa');
        camposTelefone.forEach(campo => {
            mascaraTelefone(campo);
        });
        
        // Aplicar máscaras para campos de CEP
        const camposCEP = document.querySelectorAll('#cep, #cepEmpresa');
        camposCEP.forEach(campo => {
            mascaraCEP(campo);
        });
        
        // Aplicar máscara para campo de CNPJ com validação em tempo real
        const camposCNPJ = document.querySelectorAll('#cnpj, #cnpjEmpresa');
        camposCNPJ.forEach(campo => {
            aplicarMascaraCNPJ(campo);
        });
        
        // Aplicar máscara para campo de placa com validação em tempo real
        const camposPlaca = document.querySelectorAll('#placa, #placaVeiculo');
        camposPlaca.forEach(campo => {
            aplicarMascaraPlaca(campo);
        });
        
        // Aplicar máscara para campo de RENAVAM
        const campoRENAVAM = document.querySelector('#renavam');
        if (campoRENAVAM) {
            mascaraRENAVAM(campoRENAVAM);
        }
        
        // Aplicar máscara para campo de CNH
        const campoCNH = document.querySelector('#cnhMotorista');
        if (campoCNH) {
            mascaraCNH(campoCNH);
        }
        
        // Aplicar máscara para campo de número de apólice
        const campoApolice = document.querySelector('#numeroApolice');
        if (campoApolice) {
            mascaraApolice(campoApolice);
        }
        
        // Aplicar máscara para campo de CPF
        const campoCPF = document.querySelector('#cpf');
        if (campoCPF) {
            mascaraCPF(campoCPF);
        }
        
        // Aplicar máscara para campos de email
        const camposEmail = document.querySelectorAll('#email, input[type="email"]');
        camposEmail.forEach(campo => {
            mascaraEmail(campo);
        });
        
        // Aplicar máscara para campos de complemento
        const camposComplemento = document.querySelectorAll('#complemento, #complementoEmpresa');
        camposComplemento.forEach(campo => {
            mascaraComplemento(campo);
        });
        
        // Aplicar máscaras para campos de endereço (rua, bairro, cidade)
        const camposEndereco = document.querySelectorAll('#rua, #bairro, #cidade, #ruaEmpresa, #bairroEmpresa, #cidadeEmpresa');
        camposEndereco.forEach(campo => {
            mascaraEndereco(campo);
        });
        
        // Aplicar máscaras para campos de nome
        const camposNome = document.querySelectorAll('#nome, #nomeMotorista, #nomeEmpresa, #nomeResponsavel, #nomeCompleto, #nomeEmergencia, #nomeSeguradora, #razaoSocial, #nomeFantasia');
        camposNome.forEach(campo => {
            mascaraNome(campo);
        });
        
        // Aplicar máscaras para campos numéricos
        const camposNumero = document.querySelectorAll('#numero, #numeroEmpresa, #anoFabricacao, #anoModelo, #capacidadePassageiros, #lotacaoMaxima');
        camposNumero.forEach(campo => {
            mascaraNumero(campo);
        });
        
        // Aplicar máscara para campo de cor
        const camposCor = document.querySelectorAll('#cor, #corVeiculo');
        camposCor.forEach(campo => {
            mascaraCor(campo);
        });
        
        // Aplicar máscaras para campos de data
        const camposData = document.querySelectorAll('input[type="date"], #dataNascimento, #validadeApolice, #validadeCNH, #validadeSeguro');
        camposData.forEach(campo => {
            // Alterar o tipo para text para permitir a aplicação da máscara
            campo.type = 'text';
            mascaraData(campo);
            
            // Adicionar placeholder para indicar o formato
            campo.placeholder = 'DD/MM/AAAA';
        });
        
        // Limitar caracteres para campos específicos
        const camposLimitados = [
            { selector: '#numero', maxLength: 10 },
            { selector: '#numeroEmpresa', maxLength: 10 },
            { selector: '#placa', maxLength: 7 },
            { selector: '#renavam', maxLength: 11 },
            { selector: '#cnhMotorista', maxLength: 11 },
            { selector: '#numeroApolice', maxLength: 20 },
            { selector: '#anoFabricacao', maxLength: 4 },
            { selector: '#anoModelo', maxLength: 4 },
            { selector: '#lotacaoMaxima', maxLength: 3 },
            { selector: '#nomeCompleto', maxLength: 100 },
            { selector: '#nomeEmergencia', maxLength: 100 },
            { selector: '#nomeSeguradora', maxLength: 100 },
            { selector: '#razaoSocial', maxLength: 100 },
            { selector: '#nomeFantasia', maxLength: 100 },
            { selector: '#rua', maxLength: 100 },
            { selector: '#bairro', maxLength: 50 },
            { selector: '#ruaEmpresa', maxLength: 100 },
            { selector: '#bairroEmpresa', maxLength: 50 },
            { selector: '#complemento', maxLength: 50 },
            { selector: '#complementoEmpresa', maxLength: 50 },
            { selector: '#corVeiculo', maxLength: 30 },
            { selector: '#email', maxLength: 100 }
        ];
        
        camposLimitados.forEach(campo => {
            const elementos = document.querySelectorAll(campo.selector);
            elementos.forEach(elemento => {
                limitarCaracteres(elemento, campo.maxLength);
            });
        });
        
        // Inicializar tooltips informativos para campos com validações especiais
        const camposComTooltips = [
            { selector: '#dataNascimento', tipo: 'dataNascimento' },
            { selector: '#validadeCNH', tipo: 'validadeCNH' },
            { selector: '#validadeSeguro', tipo: 'validadeSeguro' },
            { selector: '#email', tipo: 'email' },
            { selector: '#telefone', tipo: 'telefone' },
            { selector: '#telefoneEmergencia', tipo: 'telefone' },
            { selector: '#telefoneEmpresa', tipo: 'telefone' },
            { selector: '#cpf', tipo: 'cpf' },
            { selector: '#cpfMotorista', tipo: 'cpf' },
            { selector: '#cep', tipo: 'cep' },
            { selector: '#cepEmpresa', tipo: 'cep' }
        ];
        
        camposComTooltips.forEach(campo => {
             const elementos = document.querySelectorAll(campo.selector);
             elementos.forEach(elemento => {
                 adicionarTooltipInformativo(elemento, campo.tipo);
             });
         });
         
         // Inicializar indicadores visuais de campos obrigatórios vs opcionais
         adicionarIndicadoresCampos();
         
         // ===== INICIALIZAR FUNCIONALIDADES AVANÇADAS =====
         
         // Auto-preenchimento de CEP
         camposCEP.forEach(campo => {
             aplicarAutoPreenchimentoCEP(campo);
         });
         
         // Máscara inteligente de telefone
         camposTelefone.forEach(campo => {
             aplicarMascaraTelefoneInteligente(campo);
         });
         
         // Validação completa de CPF
         const camposCPF = document.querySelectorAll('#cpf, #cpfMotorista');
         camposCPF.forEach(campo => {
             aplicarValidacaoCPFCompleta(campo);
         });
         
         // Validação de CNH
         const camposCNH = document.querySelectorAll('#cnhMotorista, #cnh');
         camposCNH.forEach(campo => {
             aplicarMascaraCNH(campo);
         });
    } catch (erro) {
        console.error("Erro ao inicializar máscaras:", erro);
    }
}

// Inicializar as máscaras quando o DOM estiver carregado
document.addEventListener('DOMContentLoaded', function() {
    // Aguardar um pouco para garantir que todos os elementos estejam prontos
    setTimeout(inicializarMascaras, 100);
});

// Também tentar inicializar quando a página estiver completamente carregada
window.addEventListener('load', function() {
    setTimeout(inicializarMascaras, 100);
});

/* === ui-utils.js === */
/**
 * Utilitários de UI para melhorar a experiência do usuário
 * Inclui loading states, notificações e feedback visual
 */

// Sistema de notificações
class NotificationSystem {
    constructor() {
        this.container = null;
        this.init();
    }

    init() {
        // Criar container de notificações se não existir
        if (!document.getElementById('notification-container')) {
            this.container = document.createElement('div');
            this.container.id = 'notification-container';
            this.container.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                max-width: 400px;
            `;
            document.body.appendChild(this.container);
        } else {
            this.container = document.getElementById('notification-container');
        }
    }

    show(message, type = 'info', duration = 5000) {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        
        const colors = {
            success: '#4CAF50',
            error: '#f44336',
            warning: '#ff9800',
            info: '#2196F3'
        };

        notification.style.cssText = `
            background: ${colors[type] || colors.info};
            color: white;
            padding: 16px 20px;
            margin-bottom: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.4;
            position: relative;
            cursor: pointer;
        `;

        notification.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: space-between;">
                <span>${message}</span>
                <span style="margin-left: 15px; font-size: 18px; opacity: 0.8;">&times;</span>
            </div>
        `;

        this.container.appendChild(notification);

        // Animar entrada
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 10);

        // Auto-remover
        const removeNotification = () => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        };

        // Remover ao clicar
        notification.addEventListener('click', removeNotification);

        // Auto-remover após duração especificada
        if (duration > 0) {
            setTimeout(removeNotification, duration);
        }

        return notification;
    }

    success(message, duration = 5000) {
        return this.show(message, 'success', duration);
    }

    error(message, duration = 7000) {
        return this.show(message, 'error', duration);
    }

    warning(message, duration = 6000) {
        return this.show(message, 'warning', duration);
    }

    info(message, duration = 5000) {
        return this.show(message, 'info', duration);
    }
}

// Sistema de Loading States
class LoadingSystem {
    constructor() {
        this.activeLoaders = new Set();
    }

    // Loading para botões
    showButtonLoading(button, text = 'Carregando...') {
        if (!button) return null;

        const originalText = button.textContent;
        const originalDisabled = button.disabled;

        button.disabled = true;
        button.style.position = 'relative';
        button.style.color = 'transparent';

        const loader = document.createElement('div');
        loader.className = 'button-loader';
        loader.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            color: white;
            font-size: 14px;
        `;

        loader.innerHTML = `
            <div style="
                width: 16px;
                height: 16px;
                border: 2px solid rgba(255,255,255,0.3);
                border-top: 2px solid white;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin-right: 8px;
            "></div>
            ${text}
        `;

        // Adicionar animação de rotação se não existir
        if (!document.getElementById('loading-styles')) {
            const style = document.createElement('style');
            style.id = 'loading-styles';
            style.textContent = `
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
                @keyframes pulse {
                    0%, 100% { opacity: 1; }
                    50% { opacity: 0.5; }
                }
            `;
            document.head.appendChild(style);
        }

        button.appendChild(loader);

        const loaderId = Date.now() + Math.random();
        this.activeLoaders.add(loaderId);

        return {
            id: loaderId,
            stop: () => {
                if (this.activeLoaders.has(loaderId)) {
                    button.textContent = originalText;
                    button.disabled = originalDisabled;
                    button.style.color = '';
                    if (loader.parentNode) {
                        loader.parentNode.removeChild(loader);
                    }
                    this.activeLoaders.delete(loaderId);
                }
            }
        };
    }

    // Loading para formulários
    showFormLoading(form) {
        if (!form) return null;

        const overlay = document.createElement('div');
        overlay.className = 'form-loading-overlay';
        overlay.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            border-radius: inherit;
        `;

        overlay.innerHTML = `
            <div style="text-align: center;">
                <div style="
                    width: 40px;
                    height: 40px;
                    border: 4px solid #f3f3f3;
                    border-top: 4px solid #3498db;
                    border-radius: 50%;
                    animation: spin 1s linear infinite;
                    margin: 0 auto 10px;
                "></div>
                <div style="color: #666; font-size: 14px;">Processando...</div>
            </div>
        `;

        form.style.position = 'relative';
        form.appendChild(overlay);

        const loaderId = Date.now() + Math.random();
        this.activeLoaders.add(loaderId);

        return {
            id: loaderId,
            stop: () => {
                if (this.activeLoaders.has(loaderId) && overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                    this.activeLoaders.delete(loaderId);
                }
            }
        };
    }

    // Loading para páginas inteiras
    showPageLoading(message = 'Carregando...') {
        const overlay = document.createElement('div');
        overlay.id = 'page-loading-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        `;

        overlay.innerHTML = `
            <div style="text-align: center;">
                <div style="
                    width: 60px;
                    height: 60px;
                    border: 6px solid #f3f3f3;
                    border-top: 6px solid #3498db;
                    border-radius: 50%;
                    animation: spin 1s linear infinite;
                    margin: 0 auto 20px;
                "></div>
                <div style="color: #666; font-size: 16px; font-weight: 500;">${message}</div>
            </div>
        `;

        document.body.appendChild(overlay);

        return {
            stop: () => {
                const existingOverlay = document.getElementById('page-loading-overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
            }
        };
    }

    // Parar todos os loadings
    stopAll() {
        this.activeLoaders.forEach(loaderId => {
            // Os loaders individuais se limpam automaticamente
        });
        this.activeLoaders.clear();

        // Remover overlay de página se existir
        const pageOverlay = document.getElementById('page-loading-overlay');
        if (pageOverlay) {
            pageOverlay.remove();
        }
    }
}

// Instâncias globais
const notifications = new NotificationSystem();
const loading = new LoadingSystem();

// Funções de conveniência globais
window.showNotification = (message, type, duration) => notifications.show(message, type, duration);
window.showSuccess = (message, duration) => notifications.success(message, duration);
window.showError = (message, duration) => notifications.error(message, duration);
window.showWarning = (message, duration) => notifications.warning(message, duration);
window.showInfo = (message, duration) => notifications.info(message, duration);

window.showButtonLoading = (button, text) => loading.showButtonLoading(button, text);
window.showFormLoading = (form) => loading.showFormLoading(form);
window.showPageLoading = (message) => loading.showPageLoading(message);
window.stopAllLoading = () => loading.stopAll();

// Exportar para uso em módulos
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { notifications, loading };
}

